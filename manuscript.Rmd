---
title: |
  | Neural correlates of the uncanny valley effect
  | for robots and hyper-realistic masks 
output:
  word_document: default
  bookdown::pdf_document2:
    fig_caption: yes
    toc: no
    keep_tex: yes
  pdf_document:
    toc: no
  html_document: default
bibliography: references.bib
csl: plos.csl
author: |
  | Shona Fitzpatrick$^1$, Ailish K. Byrne$^2$, Alex Headley$^1$, Jet G. Sanders$^3$,
  | Helen Petrie$^4$, Rob Jenkins$^1$ & Daniel H. Baker$^{1,5}$
---

1. Department of Psychology, University of York, York, UK
2. School of Medicine, Keele University, Newcastle-under-Lyme, Staffordshire, UK
3. Department of Psychological and Behavioural Science, London School of Economics, London, UK
4. Department of Computer Science, University of York, York, UK
5. Corresponding author, email: daniel.baker\@york.ac.uk

```{r setup, include=FALSE}

processdata <- 0  # this flag determines the amount of processing, with 3 levels:
# 0 - do no processing, generate the pdf using existing versions of all figures
# 1 - generate figures using the processed group data (requires 120MB of storage)
# 2 - do statistics and bootstrapping using processed data

nbootstraps <- 1000
targetelectrodes <- c(28,54,58,64)

# check which packages are installed, install the missing ones, and activate
packagelist <- c('knitr','e1071','signal','osfr','tictoc','BayesFactor','reshape2','R.matlab') # list of CRAN packages
missingpackages <- packagelist[!packagelist %in% installed.packages()[,1]]
if (length(missingpackages)>0){install.packages(missingpackages)}
toinstall <- packagelist[which(!packagelist %in% (.packages()))]
invisible(lapply(toinstall,library,character.only=TRUE))

if (!dir.exists('local/')){dir.create('local/')}
if (!dir.exists('local/robotsmvpa/')){dir.create('local/robotsmvpa/')}
if (!dir.exists('local/masksmvpa/')){dir.create('local/masksmvpa/')}


collist <- c('lightsalmon','forestgreen','cornflowerblue')
bfcols <- c('gold','darkorange','firebrick')
colfunc <- colorRampPalette(c("darkgreen", "darkblue"))
colvect <- colfunc(29)
addalpha <- function(col, alpha=1){apply(sapply(col, col2rgb)/255, 2, function(x) rgb(x[1], x[2], x[3], alpha=alpha))}

getstartstop <- function(linestartstop){
  xpairs <- matrix(0, nrow = 1200, ncol = 2)
  paircounter <- 1
  startval <- linestartstop[1]
  lastval <- linestartstop[1]
  for (n in 2:length(linestartstop)){
    if ((linestartstop[n] - lastval) > 1){
      xpairs[paircounter, ] <- c(startval, lastval)
      startval <- linestartstop[n]
      paircounter <- paircounter + 1
    }
    lastval <- linestartstop[n]
  }
  xpairs[paircounter,] <- c(startval,lastval)
  xpairs <- xpairs[1:(paircounter+1),1:2]
  return(xpairs)}

# two functions used in prewhitening prior to MVPA
# data must be in the format sensor x time x trials
cov1para <- function(x){
  
  s <- dim(x)
  ti <- s[1]
  n <- s[2]
  meanx <- colMeans(x)
  x <- x - matrix(rep(meanx,ti),nrow=ti,ncol=n,byrow=TRUE)
  
  sample <- (1/ti)*(t(x)%*%x)
  
  meanvar <- sum(diag(sample))/n
  prior <- meanvar * diag(n)
  
  y <- x^2
  phiMat <- t(y) %*% y/ti - sample^2
  phi <- sum(phiMat)
  
  gamma <- sample - prior
  gamma <- sum(gamma^2)
  
  kappa <- phi/gamma
  shrinkage <- max(0,min(1,kappa/ti))
  
  sigma <- shrinkage * prior + (1-shrinkage) * sample
  
  return(sigma)}

whitenmatrix <- function(data,condid){
  
  # set up variables
  s <- dim(data)
  nvar <- s[1]
  ntimes <- s[2]
  ncond <- max(condid)
  Cov <- matrix(0,nrow=nvar,ncol=nvar)
  
  # compute whitening matrix
  for (cond in 1:ncond){
    dat <- data[,,which(condid==cond)]
    for (time in 1:ntimes){
      sigma <- cov1para(t(dat[,time,]))
      Cov <- Cov + sigma
    }
  }
  Cov <- Cov/(ncond*ntimes)
  W <- powerplus::Matpow(Cov,-0.5)
return(W)}

knitr::opts_chunk$set(echo = TRUE)
  
filelist <- c('channel.mat','channeldata.csv','maskquestionnairelong.csv','robotquestionnairelong.csv')

for (f in 1:length(filelist)){
  if (!file.exists(paste0('local/',filelist[f]))){
  osfproject <- osf_retrieve_node('uzbns')
  osffiles <- osf_ls_files(osfproject,n_max=100)
  fid <- which(osffiles$name==filelist[f])
  osf_download(osffiles[fid,], path='local/',progress=TRUE)}
}  

```

# Abstract

Viewing artificial objects and images that are designed to appear human can elicit a sense of unease, referred to as the 'uncanny valley' effect. Here we investigate neural correlates of the uncanny valley, using still images of androids (robots designed to look human), and humans wearing hyper-realistic silicone masks, as well as still images of real humans, in two experiments. In both experiments, human-like stimuli were harder to distinguish from real human faces than stimuli that were clearly not designed to mimic humans but contain facial features (mechanical robots and Halloween masks). Stimulus evoked potentials (electromagnetic brain responses) did not show convincing differences between faces and either androids or realistic masks when using traditional univariate statistical tests. However, a more sensitive multivariate analysis identified two regions of above-chance decoding, indicating neural differences in the response between human faces and androids/realistic masks. The first time window was around 100-200ms post stimulus onset, and most likely corresponds to low-level image differences between conditions. The second time window was around 600ms post stimulus onset, and may reflect top-down processing, and may correspond to the subjective sense of unease characteristic of the uncanny valley effect. Objective neural components might be used in future to rapidly train generative artificial intelligence systems to produce more realistic images that are perceived as natural by human observers.

# Introduction

Many people report an aversion to entities that are superficially human-like, but on closer inspection turn out to be artificial. Examples include humanoid robots (androids), puppets, hyper-realistic masks [@Sanders2021], and computer-generated images or movies. The term 'uncanny valley' [@Mori1970;  English translation in @Mori2012] describes the idea that clearly human or clearly artificial entities do not evoke unease, whereas artificial entities that are human-like are disconcerting. Understanding these experiences is increasingly important as artificial entities become more integrated into our everyday lives. However at present relatively little is known about the neural underpinnings of the uncanny valley effect [for a recent review, see @Vaitonyte2023]. In particular, the root of the uncanny valley effect remains debated: does it arise primarily from bottom-up sensory conflicts, or from higher-level cognitive processes? Resolving this question is critical to understanding its fundamental mechanisms.

Neural responses to faces and bodies in general are well-characterised, and there appear to be specialised brain regions devoted to both [reviewed in @Hu2020]. For example, areas of the occipital lobe [@Gauthier2000] and fusiform gyrus [@Kanwisher1997] respond more to faces than non-face stimuli, and sections of extrastriate cortex are responsive to bodies [@Downing2001]. There are also electromagnetic event-related potential (ERP) signals associated with face and body stimuli, though their precise role is still debated [@Thierry2007; @Hong2022]. It seems highly likely that 'uncanny' images will activate these same processes, yet it is unclear whether the initial cause of the sense of unease they produce occurs at bottom-up sensory stages [@MacDorman2024; @MacDorman2016; @Moore2012] or is modulated by more top-down cognitive factors [@Gray2012; @Yam2021].

One previous study by @Saygin2012 measured functional magnetic resonance imaging (fMRI) responses to moving stimuli designed to elicit an uncanny valley effect. They found repetition suppression effects^[Repetition suppression is a phenomenon in which the neural response to repeated presentations of identical or similar stimuli is reduced relative to the response on the first presentation.] in action-specific brain regions responding to movies of androids that had a biological appearance, but mechanical motion. These effects were stronger than for movies of humans or mechanical robots performing the same actions. A more recent electroencephalography (EEG) study [@Urgen2018] identified a difference in the N400 component^[The N400 is an electromagnetic brain potential obtained 400ms after stimulus onset, typically over centro-parietal electrodes. It has been proposed to reflect the extent to which the stimulus presented was surprising or unexpected.] between dynamic and static conditions using the same stimuli. Although this difference was strongest over frontal electrodes, source reconstruction of the N400 itself suggested a left-lateralised source in the temporo-parietal cortex, consistent with the fMRI results [@Saygin2012]. The authors interpret both of these findings as being due to the discrepancy between the human-like appearance and the clearly non-biological motion of the robot.

Our aim was to further investigate neural correlates of the uncanny valley effect, with the expectation that increased understanding will aid efforts to generate more convincingly human robots and avatars in the future. We achieved this through two EEG experiments, in which we measured neural responses to static images. Although previous studies focus on dynamic stimuli, static images allow for a more precise investigation of the neural mechanisms underlying the uncanny valley effect, particularly by eliminating motion-related confounds. In the first experiment, the stimuli were still images of humans, machine-like robots, and human-like robots (see Figure \ref{fig:stimexamples}a). In the second experiment we aimed to generalise the finding by using images of people wearing no masks, wearing obvious masks (e.g. Halloween masks), and wearing hyper-realistic silicone masks [@Sanders2017] (see Figure \ref{fig:stimexamples}b). Rather than focus on specific ERP components, we use a multivariate pattern classification approach (a machine learning technique in which an algorithm is trained to decode the neural responses) to identify time windows in which information in the EEG signal can be used to distinguish between pairs of conditions. Our rationale is that timepoints where signals evoked by human faces can be distinguished from those evoked by human-like robots, or hyper-realistic masks, are candidates for a neural signature of the uncanny valley effect.

```{r stimexamples, fig.cap="Illustrative stimuli from the same categories as used in Experiments 1 and 2. Row (a) shows a human face, an android and a robot, all against white backgrounds. Row (b) shows a human face, a hyper-realistic silicone mask, and a Halloween mask, all against natural backgrounds. Images shown here were taken from a variety of sources that permit reuse in academic contexts and in most cases were not part of the stimulus set from the experiments. The silicone mask image was taken by the authors (subject: RJ, image credit: JGS), and was used in Experiment 2. The individual in this manuscript has given written informed consent (as outlined in PLOS consent form) to publish these case details (i.e. this image).", fig.align="center", out.width='80%', echo=FALSE}

knitr::include_graphics('Figures/stimfigure.jpg')

```

# Materials & Methods

## Participants

A total of 29 participants completed Experiment 1 (12 male, 17 female), and 30 different participants completed Experiment 2 (7 male, 23 female). Participants were young adults with no history of neurological disorder. None of the participants had previously taken part in a study using these stimuli, and all were naïve to the hypotheses and wore their normal optical correction if required. Written informed consent was collected before each experiment began, and all procedures were approved by the Ethics committee of the Department of Psychology at the University of York. Data collection for Experiment 1 ran from 14th July to 15th September 2022, and data collection for Experiment 2 ran from 12th October 2017 to 14th February 2018.

## Apparatus & stimuli

In Experiment 1, the stimulus set consisted of a total of 90 images, evenly split between three categories: real faces, human-like robots, and mechanical robots. Images all showed the head and shoulders of the subject, had white backgrounds, and were sourced from the Internet. In Experiment 2, the stimulus set (first described by @Sanders2019, but here including additional images) consisted of a total of 296 images, comprising real faces (148 images), people wearing silicone masks (74 images), and people wearing obvious masks of the sort typically worn for carnivals and Halloween celebrations (74 images). The backgrounds of these images were more heterogeneous, and showed the natural surroundings of the subject. While the image backgrounds differed across experiments, we hypothesize that the primary task was not affected, as participants focused on the foreground stimuli. In both experiments, images included examples of both genders, and of varied ethnic backgrounds.

All stimuli were displayed on a ViewPixx display running at 120Hz, controlled by an Apple Macintosh computer. The display was gamma corrected using a photometer to ensure that the luminance output was linear. EEG data were collected using a 64-channel Waveguard cap and an ANT Neuroscan system, sampling at 1kHz. The ground electrode was located at position $AFz$, and all signals were referenced to the whole head average. Low latency digital triggers were sent between the display and the EEG amplifier using an 8-bit parallel cable.

## Procedure

### Experiment 1: Robots

Each participant completed three blocks of the first experiment. Within each block, all 90 stimulus images were presented twice in a random order. Stimuli subtended $11\times11$ degrees at the viewing distance of 57cm, and were shown against a mid-grey background, with a black central fixation cross displayed throughout. The presentation duration was 500ms, and participants were asked to press a mouse button to indicate if they believed each image was of a human or of a robot/android. After each response there was a random duration blank period with a mean duration of 1000ms and a standard deviation of 200ms. Durations were chosen to provide sufficient information for judgment while avoiding task fatigue. Randomized blank periods were designed to reduce carryover effects and prevent anticipatory biases. Each block lasted around 6 minutes.

After the EEG experiment, participants also completed a series of questionnaires using the Qualtrics platform. These involved rating their perception of a subset of the stimuli (8 from each category), using items from the Godspeed questionnaire [@Bartneck2009]. Items were selected that were expected to be most closely aligned to measuring the sensation of uncanniness. Inspection time was unlimited. Participants also provided demographic information (age, gender) and completed the GAToRS [@Koverola2022] and AQ [@Baron-Cohen2001] questionnaires, however the results of these additional questionnaires are not presented here.

### Experiment 2: Hyper-realistic masks

Participants were shown all 296 images in a random order in each of three blocks. In the first block, stimuli subtended $5.5\times7.5$ degrees of visual angle when viewed at a distance of 57cm. In the second block, stimuli doubled in size (width and height), and subtended $11\times15$ degrees at the same viewing distance. In the third block, stimuli doubled in size again, and subtended $22\times30$ degrees. The rationale for the size manipulation was to investigate whether increasing levels of detail made the silicone masks more identifiable [@Sanders2017; @Sanders2019]. However as that is not the main focus of the current paper, and our preliminary analyses indicated no differences between size conditions, we collapse results across size conditions. Stimuli were presented for 250ms, and participants indicated whether they thought each image contained a real face or a mask, using a two-button trackball. The button assignment (whether the left button indicated a face or a mask, and vice versa) was determined randomly for each participant, but remained constant throughout the whole experiment. Text reminding the participant of the button assignment was present continuously in the lower right corner of the screen, far from the area of the screen where the stimuli were presented. A central fixation cross was also present throughout. After each response there was a random duration blank period with a mean duration of 1000ms and a standard deviation of 200ms. Each block lasted around 8 minutes.

An independent group of 20 participants also completed an online questionnaire in which they rated the images along various dimensions. The participants repeated the real face vs mask judgement from the main experiment, and were additionally asked to rate emotional expressiveness, realism, and uncanniness for each image using a 7-point Likert scale. Inspection time was unlimited for these judgments.

## Data analysis

We analysed response data by calculating d-prime ($d'$) scores for each condition, derived from the hit rate and false alarm rate [@Macmillan2005]. For the human conditions, the hit rate was the proportion of human images correctly identified as human, and the false alarm rate was the proportion of robot or mask images that were incorrectly judged as being human. For the robot and mask conditions, the hit rate was the proportion of robot/mask images correctly identified as not being human, and the false alarm rate was the proportion of human images that were incorrectly judged as being non-human (note that this means the false alarm rate was the same for the robot and android conditions, and for the silicone and Halloween mask conditions). We capped infinite d-prime values (which occur e.g. when the hit rate is 1) at an arbitrary ceiling of 5 to prevent outliers from skewing the results, following established conventions in signal detection theory. We log transformed the reaction times (which typically have positive skew) and performed all averaging and statistical analysis on the logarithmic values.

EEG signals were recorded during each block and saved to disc for subsequent offline analysis. We used components of the EEGlab toolbox [@Delorme2004] to import the data into Matlab and collate data across blocks. We then used Brainstorm [@Tadel2011] to filter the data using a bandpass filter (0.5 to 30Hz), epoch by condition, and subtract a pre-trial baseline (the mean voltage for the 200ms before stimulus onset). Five participants were excluded from the EEG analysis of each experiment due to excessive noise. Our attempts to clean up the data from these participants using independent components analysis were unsuccessful. Their behavioural data were unaffected, and are therefore still included in the analysis.

We performed univariate analyses by conducting Bayesian t-tests [@Rouder2009] between ERPs from pairs of conditions at each time point using a JZS prior, using signals pooled across electrodes P6, P8, PO6 and PO8, which are typically associated with visual responses to faces. The resulting Bayes factor score is a summary of the evidence in favour of either the null hypothesis (that the waveforms are equal) or the alternative hypothesis (that they differ). We use the heuristics proposed by Jeffreys @Jeffreys1961 that Bayes factors >3 ($log_{10}BF_{10}$ > 0.5) constitute some evidence supporting the alternative hypothesis, factors >10 ($log_{10}BF_{10}$ > 1) constitute strong evidence, and factors >30 ($log_{10}BF_{10}$ > 1.5) constitute very strong evidence.

Multivariate pattern analysis (MVPA) was conducted by training a linear support vector machine algorithm [LibSVM, @Chang2011] to discriminate between patterns of activity across electrodes at a specific time point. MVPA is a statistical technique that involves training a machine learning algorithm to identify patterns in data, and then testing its accuracy at classifying unseen data; in EEG analysis above-chance classification is considered evidence of distinct patterns of neural activity between two conditions. Previous work has indicated that EEG data do not typically require more complex nonlinear algorithms [@Grootswagers2017]. The patterns came from the human face condition and one of the other conditions, for a single participant. Four examples of each pattern were calculated by averaging over random subsets of 20\% of the available trials from a given condition, and these were used to train the classifier. The accuracy of the classifier was tested on the remaining trials (that were not used in training) for each condition. This process was repeated 1000 times with different trial permutations to obtain an average accuracy, where chance performance is at 50\% correct. The analysis was carried out at all time points, and for each participant separately. We then averaged classifier accuracy across participants, and calculated one sample Bayesian t-tests comparing to chance performance at each time point as described above.

## Data and code availability

Raw data, processed data, and analysis scripts are freely available through the project repository at: https://doi.org/10.17605/OSF.IO/5NZ2H

# Results

## Experiment 1

```{r exp1stats, include=FALSE, results='hide'}

# statistical analysis for experiment 1
processeddir <- 'local/robotsmvpa/'
excludelist <- c(2,4,5,9,13)

if (processdata > 1){
  
  if (!file.exists('local/robotsmvpa/301_101.mat')){
  osffiles <- osf_retrieve_file('pzcd9')
  osf_download(osffiles, path='local/',progress=TRUE,conflicts='overwrite')
  unzip('local/robotsmvpa.zip',exdir='local/',overwrite=TRUE)
  }
  if (!file.exists('local/responsedata/301trialorderRobots.mat')){
  osffiles <- osf_retrieve_file('fvsq8')
  osf_download(osffiles, path='local/',progress=TRUE,conflicts='overwrite')
  unzip('local/responsedata.zip',exdir='local/',overwrite=TRUE)
  }
  comparisons <- matrix(c(1,2,1,3,2,3),nrow=3,ncol=2,byrow=TRUE)

datafiles <- dir(processeddir,pattern='*decoding.mat',full.names=TRUE)    
allmvpa <- array(0,dim=c(length(datafiles),3,1201))  
for (s in 1:length(datafiles)){
  data <- readMat(datafiles[s])
  allmvpa[s,,] <- data$Value/100
}    
times <- data$Time

datafiles1 <- dir(processeddir,pattern='*_101.mat',full.names=TRUE)    
datafiles2 <- dir(processeddir,pattern='*_102.mat',full.names=TRUE)    
datafiles3 <- dir(processeddir,pattern='*_103.mat',full.names=TRUE)    
allmeans <- array(0,dim=c(length(datafiles1),3,66,1201))
for (s in 1:length(datafiles1)){
  data <- readMat(datafiles1[s])
  allmeans[s,1,,] <- data$F*10^6
  data <- readMat(datafiles2[s])
  allmeans[s,2,,] <- data$F*10^6
  data <- readMat(datafiles3[s])
  allmeans[s,3,,] <- data$F*10^6
}     

allmvpa <- allmvpa[-excludelist,,]
allmeans <- allmeans[-excludelist,,,]

  allRobotRTs <- array(0,dim=c(29,3,180))
  allRobotaccuracy <- array(0,dim=c(29,3,180))
  allRobotdprime <- matrix(0,nrow=29,ncol=3)
  allRobottrialcounts <- matrix(0,nrow=29,ncol=3)

  for (s in 1:29){
    data <- readMat(paste0('local/responsedata/',s+300,'trialorderRobots.mat'))
    
    trialorder <- data$R[5][[1]]
    responses <- data$R[7][[1]]
    RTs <- data$R[8][[1]]
    condlist <- data$R[4][[1]]
    condcounter <- c(0,0,0)
    sortedRT <- matrix(0,nrow=3,ncol=180)
    sortedresp <- matrix(0,nrow=3,ncol=180)
    
    for (block in 1:3){
      for (trial in 1:180){
        cond <- condlist[trialorder[block,trial]]
        condcounter[cond] <- condcounter[cond] + 1
        sortedRT[cond,condcounter[cond]] <- 20*log10(RTs[block,trial] * 1000)
        sortedresp[cond,condcounter[cond]] <- responses[block,trial] - 1
      }
    }
    
      hits <- NULL
  misses <- NULL
  for (cond in 1:3){
 
  if (cond<3){
  hits[cond] <- condcounter[cond]-sum(sortedresp[cond,1:condcounter[cond]])
  misses[cond] <- sum(sortedresp[cond,1:condcounter[cond]])
  }
  if (cond==3){
  hits[cond] <- sum(sortedresp[cond,1:condcounter[cond]])
  misses[cond] <- condcounter[cond]-sum(sortedresp[cond,1:condcounter[cond]])
  }
    
  }
    hitrate <- hits/(hits + misses)
  for (cond in 1:3){
    if (cond<3){falsealarms <- misses[3]/ (misses[3] + hits[3])}
    if (cond==3){falsealarms <- sum(misses[1:2]) / (sum(misses[1:2]) + sum(hits[1:2]))}
  allRobotdprime[s,cond] <- qnorm(hitrate[cond]) - qnorm(falsealarms)
  }
    
    allRobotRTs[s,,] <- sortedRT
    allRobotaccuracy[s,,] <- sortedresp
    allRobottrialcounts[s,] <- condcounter
  }
  
allRobotdprime[which(is.infinite(allRobotdprime))] <- 5
meanRobotRTs <- apply(allRobotRTs,1:2,mean)
  
dataforANOVA <- melt(allRobotdprime)
colnames(dataforANOVA) <- c('Participant','Condition','dprime')
dataforANOVA$Participant <- as.factor(dataforANOVA$Participant)
dataforANOVA$Condition <- as.factor(dataforANOVA$Condition)
bfdprime <- extractBF(anovaBF(dprime ~ Condition,dataforANOVA,whichRandom='Participant'))$bf

bfcontrasts <- NULL
for (comp in 1:3){
bfcontrasts[comp] <- extractBF(ttestBF(allRobotdprime[,comparisons[comp,1]],allRobotdprime[,comparisons[comp,2]],paired=TRUE))$bf}

dataforANOVA <- melt(meanRobotRTs)
colnames(dataforANOVA) <- c('Participant','Condition','RT')
dataforANOVA$Participant <- as.factor(dataforANOVA$Participant)
dataforANOVA$Condition <- as.factor(dataforANOVA$Condition)
bfRT <- extractBF(anovaBF(RT ~ Condition,dataforANOVA,whichRandom='Participant'))$bf

bfcontrastsRT <- NULL
for (comp in 1:3){
bfcontrastsRT[comp] <- extractBF(ttestBF(meanRobotRTs[,comparisons[comp,1]],meanRobotRTs[,comparisons[comp,2]],paired=TRUE))$bf}

subjmeanERP <- apply(allmeans,c(1,3,4),mean)
meanERP <- apply(allmeans,2:4,mean)
meanMVPA <- apply(allmvpa,2:3,mean)
grandmeanERP <- apply(subjmeanERP[,targetelectrodes,],3,mean)
subjERPs <- apply(subjmeanERP[,targetelectrodes,],c(1,3),mean)
condERPs <- apply(allmeans[,,targetelectrodes,],c(1,2,4),mean)

mlimits <- matrix(0,nrow=6,ncol=1201)
mBF <- matrix(0,nrow=3,ncol=1201)
bspop <- 1:nbootstraps
for (n in 1:1201){

  for (cond in 1:3){
  for (b in 1:nbootstraps){
    bspop[b] <- mean(sample(allmvpa[,cond,n],replace=TRUE))
  }
mlimits[(1:2)+((cond-1)*2),n] <- quantile(bspop,probs=c(0.025,0.975)) 
mBF[cond,n] <- extractBF(ttestBF(allmvpa[,cond,n],mu=0.5))$bf
  }
}

limits <- matrix(0,nrow=8,ncol=1201)
ERP_BF <- matrix(0,nrow=3,ncol=1201)
bspop <- 1:nbootstraps
for (n in 1:1201){

  for (b in 1:nbootstraps){
    bspop[b] <- mean(sample(subjERPs[,n],replace=TRUE))
  }
  limits[1:2,n] <- quantile(bspop,probs=c(0.025,0.975)) 
  
  for (cond in 1:3){
  for (b in 1:nbootstraps){
    bspop[b] <- mean(sample(condERPs[,cond,n],replace=TRUE))
  }
  limits[(1:2)+(cond*2),n] <- quantile(bspop,probs=c(0.025,0.975)) 
  ERP_BF[cond,n] <- extractBF(ttestBF(condERPs[,comparisons[cond,1],n],condERPs[,comparisons[cond,2],n],paired=TRUE))$bf
  }
}


chlist <- readMat('local/channel.mat')
chanlabels <- unlist(chlist$HeadPoints[[2]])
chanlocs <- read.csv('local/channeldata.csv')


save(file='local/GroupDataRobots.RData',list=c('allmeans','allmvpa','mlimits','subjmeanERP','limits','grandmeanERP','subjERPs','condERPs','meanMVPA','meanERP','mBF','ERP_BF','allRobotdprime','meanRobotRTs','bfdprime','bfRT','bfcontrasts','bfcontrastsRT','chanlocs','chanlabels'))

}

```

```{r exp1fig, include=FALSE, results='hide'}

# create figures for experiment 1

  if (!file.exists('local/GroupDataRobots.RData')){
  osfproject <- osf_retrieve_node('uzbns')
  osffiles <- osf_ls_files(osfproject,n_max=100)
  fid <- which(osffiles$name=='GroupDataRobots.RData')
  osf_download(osffiles[fid,], path='local/',progress=TRUE)}

load('local/GroupDataRobots.RData')
if (processdata > 0){

pdf(paste0('Figures/RobotsData.pdf'), bg="transparent", height = 12, width = 12)

par(mfrow=c(2,2))

  plotlims <- c(0,5,0.5,3.5)  
  ticklocsy <- c(0.5,1,2,3,3.5)    
  ticklocsx <- 0:5    # locations of tick marks on y axis
  ticklabelsy <- c("","Robot","Android","Human","")       
  ticklabelsx <- ticklocsx    # set labels for y ticks
  
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
  axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
  axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
  mtext(text = ticklabelsx, side = 1, at=ticklocsx,line=0.5,cex=1.5)     
  mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=3,cex=1.5) 
  title(xlab="d prime", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.8)

  text(0.15,3.3,'(a)',cex=3)
  
  a <- density(allRobotdprime[,1],cut=6)
  a$y <- 0.35*a$y/max(a$y)
  polygon(a$x,1.1+a$y,border=NA,col=addalpha(collist[1],0.5))

    a <- density(allRobotdprime[,2])
  a$y <- 0.35*a$y/max(a$y)
  polygon(a$x,2.1+a$y,border=NA,col=addalpha(collist[2],0.5))

    a <- density(allRobotdprime[,3])
  a$y <- 0.35*a$y/max(a$y)
  polygon(a$x,3.1+a$y,border=NA,col=addalpha(collist[3],0.5))

  xvals <- seq(-0.1,0.1,length=nrow(allRobotdprime))
  points(allRobotdprime[,1],1+xvals-0.2,pch=16,col=collist[1])
  points(allRobotdprime[,2],2+xvals-0.2,pch=15,col=collist[2])
  points(allRobotdprime[,3],3+xvals-0.2,pch=18,col=collist[3])

  for (cond in 1:3){
  bs <- NULL
  for (n in 1:nbootstraps){bs[n] <- mean(sample(allRobotdprime[,cond],replace=TRUE))}
  ci <- quantile(bs,c(0.025,0.975))
  arrows(mean(allRobotdprime[,cond]),cond,ci[1],cond,angle=90,length=0.1,lwd=3)
  arrows(mean(allRobotdprime[,cond]),cond,ci[2],cond,angle=90,length=0.1,lwd=3)
  }

  points(mean(allRobotdprime[,1]),1,pch=21,cex=2,lwd=2,bg=collist[1])
  points(mean(allRobotdprime[,2]),2,pch=22,cex=2,lwd=2,bg=collist[2])
  points(mean(allRobotdprime[,3]),3,pch=23,cex=2,lwd=2,bg=collist[3])


  
  plotlims <- c(52,64,0.5,3.5)  
  ticklocsy <- c(0.5,1,2,3,3.5)    
  ticklocsx <- c(52,58,64)    
  ticklabelsy <- c("","Robot","Android","Human","")       
  ticklabelsx <- c(400,800,1600)    # set labels for y ticks
  
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
  axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
  axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
  mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.5, cex=1.5)     
  mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=3,cex=1.5) 
  title(xlab="Reaction time (ms)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.8)

    text(20*log10(420),3.3,'(b)',cex=3)

  a <- density(meanRobotRTs[,1],cut=6)
  a$y <- 0.35*a$y/max(a$y)
  polygon(a$x,1.1+a$y,border=NA,col=addalpha(collist[1],0.5))

    a <- density(meanRobotRTs[,2])
  a$y <- 0.35*a$y/max(a$y)
  polygon(a$x,2.1+a$y,border=NA,col=addalpha(collist[2],0.5))

    a <- density(meanRobotRTs[,3])
  a$y <- 0.35*a$y/max(a$y)
  polygon(a$x,3.1+a$y,border=NA,col=addalpha(collist[3],0.5))

  xvals <- seq(-0.1,0.1,length=nrow(meanRobotRTs))
  points(meanRobotRTs[,1],1+xvals-0.2,pch=16,col=collist[1])
  points(meanRobotRTs[,2],2+xvals-0.2,pch=15,col=collist[2])
  points(meanRobotRTs[,3],3+xvals-0.2,pch=18,col=collist[3])

  for (cond in 1:3){
  bs <- NULL
  for (n in 1:nbootstraps){bs[n] <- mean(sample(meanRobotRTs[,cond],replace=TRUE))}
  ci <- quantile(bs,c(0.025,0.975))
  arrows(mean(meanRobotRTs[,cond]),cond,ci[1],cond,angle=90,length=0.1,lwd=3)
  arrows(mean(meanRobotRTs[,cond]),cond,ci[2],cond,angle=90,length=0.1,lwd=3)
  }
  points(mean(meanRobotRTs[,1]),1,pch=21,cex=2,lwd=2,bg=collist[1])
  points(mean(meanRobotRTs[,2]),2,pch=22,cex=2,lwd=2,bg=collist[2])
  points(mean(meanRobotRTs[,3]),3,pch=23,cex=2,lwd=2,bg=collist[3])


par(mfrow=c(2,1),mfg=c(2,1))

plotlims <- c(-200,1000,-12,12)  
ticklocsx <- seq(-200,1000,200)    # locations of tick marks on x axis
ticklocsy <- seq(-12,12,4)    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.5, cex=1.5)    
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1, cex=1.5)  
title(xlab="Time (ms)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.8)   
title(ylab="Amplitude (µV)", col.lab=rgb(0,0,0), line=2.2, cex.lab=1.8)

  text(-200,10,'(c)',cex=3)

lines(c(-200,1000),c(0,0),lty=1)
lines(c(0,0),c(-20,20),lty=1)
polygon(c(0,500,500,0),c(-13,-13,-11,-11),col=rgb(0,0,0,0.3),border=NA)

polygon(c(-200:1000,1000:-200), c(limits[1,],limits[2,1201:1]), col=rgb(0,0,0,0.1),border=NA)

lines(-200:1000, grandmeanERP, lwd=3)     

  text(105,9.5,'P100',cex=2)
  text(155,-4,'N170',cex=2)
  text(250,4,'P200',cex=2)

  
chanindex <- match(toupper(chanlabels),toupper(chanlocs$Electrode))
chanxy <- chanlocs[chanindex,2:3]
lines(150*chanlocs$OutlineX-100,7.5*chanlocs$OutlineY + 6, lwd=2)
lines(150*chanlocs$NoseX-100,7.5*chanlocs$NoseY + 6, lwd=2)
lines(150*chanlocs$LearX-100,7.5*chanlocs$LearY + 6, lwd=2)
lines(150*chanlocs$RearX-100,7.5*chanlocs$RearY + 6, lwd=2)
points(150*chanlocs$X_position[1:64]-100,7.5*chanlocs$Y_position[1:64] + 6, pch=16,col='lightgrey')
points(150*chanlocs$X_position[chanindex[targetelectrodes]]-100,7.5*chanlocs$Y_position[chanindex[targetelectrodes]] + 6, pch=16,col='black')


dev.off()






pdf(paste0('Figures/RobotsMVPA.pdf'), bg="transparent", height = 12, width = 24)

par(mfrow=c(2,2))

times <- -199:1200

plotlims <- c(-200,1000,-12,12)  
ticklocsx <- seq(-200,1000,200)    # locations of tick marks on x axis
ticklocsy <- seq(-12,12,4)    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)    
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.5, cex=1.5)    
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1, cex=1.5)  
title(xlab="Time (ms)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.8)   
title(ylab="Amplitude (µV)", col.lab=rgb(0,0,0), line=2.2, cex.lab=1.8)

lines(c(-200,1000),c(0,0),lty=1)
lines(c(0,0),c(-20,20),lty=1)
polygon(c(0,500,500,0),c(-13,-13,-11,-11),col=rgb(0,0,0,0.3),border=NA)

polygon(c(-200:1000,1000:-200), c(limits[3,],limits[4,1201:1]), col=addalpha(collist[1],0.3),border=NA)
polygon(c(-200:1000,1000:-200), c(limits[7,],limits[8,1201:1]), col=addalpha(collist[3],0.3),border=NA)

lines(-200:1000, colMeans(meanERP[1,targetelectrodes,]), lwd=3, col=collist[1])     
lines(-200:1000, colMeans(meanERP[3,targetelectrodes,]), lwd=3, col=collist[3])     

chanindex <- match(toupper(chanlabels),toupper(chanlocs$Electrode))
chanxy <- chanlocs[chanindex,2:3]
lines(150*chanlocs$OutlineX-100,7.5*chanlocs$OutlineY + 6, lwd=2)
lines(150*chanlocs$NoseX-100,7.5*chanlocs$NoseY + 6, lwd=2)
lines(150*chanlocs$LearX-100,7.5*chanlocs$LearY + 6, lwd=2)
lines(150*chanlocs$RearX-100,7.5*chanlocs$RearY + 6, lwd=2)
points(150*chanlocs$X_position[1:64]-100,7.5*chanlocs$Y_position[1:64] + 6, pch=16,col='lightgrey')
points(150*chanlocs$X_position[chanindex[targetelectrodes]]-100,7.5*chanlocs$Y_position[chanindex[targetelectrodes]] + 6, pch=16,col='black')

allbfs <- ERP_BF[2,]

linestartstop <- times[allbfs>=3 & allbfs<10]
if (length(linestartstop)>1){xpairs <- getstartstop(linestartstop)
for (n in 1:((length(xpairs)/2)-1)){polygon(xpairs[n,c(1,2,2,1)], -c(8.5,8.5,7.5,7.5), col=bfcols[1],border=NA)}}

linestartstop <- times[allbfs>=10 & allbfs<30]
if (length(linestartstop)>1){xpairs <- getstartstop(linestartstop)
for (n in 1:((length(xpairs)/2)-1)){polygon(xpairs[n,c(1,2,2,1)], -c(8.5,8.5,7.5,7.5), col=bfcols[2],border=NA)}}

linestartstop <- times[allbfs>=30]
if (length(linestartstop)>1){xpairs <- getstartstop(linestartstop)
for (n in 1:((length(xpairs)/2)-1)){polygon(xpairs[n,c(1,2,2,1)], -c(8.5,8.5,7.5,7.5), col=bfcols[3],border=NA)}}

legend(700,12,c('Human','Robot'),lty=1,lwd=3,col=collist[c(3,1)],cex=1.8,box.lwd=2)
text(-190,11,'(a)',cex=3)

legend(-200,-6,c('BF>3','BF>10','BF>30'),lwd=5,col=bfcols, box.lwd=2, cex=1.5)


plotlims <- c(-200,1000,-12,12)  
ticklocsx <- seq(-200,1000,200)    # locations of tick marks on x axis
ticklocsy <- seq(-12,12,4)    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.5, cex=1.5)    
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1, cex=1.5)  
title(xlab="Time (ms)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.8)   
title(ylab="Amplitude (µV)", col.lab=rgb(0,0,0), line=2.2, cex.lab=1.8)

lines(c(-200,1000),c(0,0),lty=1)
lines(c(0,0),c(-20,20),lty=1)
polygon(c(0,500,500,0),c(-13,-13,-11,-11),col=rgb(0,0,0,0.3),border=NA)

polygon(c(-200:1000,1000:-200), c(limits[5,],limits[6,1201:1]), col=addalpha(collist[2],0.3),border=NA)
polygon(c(-200:1000,1000:-200), c(limits[7,],limits[8,1201:1]), col=addalpha(collist[3],0.3),border=NA)

lines(-200:1000, colMeans(meanERP[2,targetelectrodes,]), lwd=3, col=collist[2])     
lines(-200:1000, colMeans(meanERP[3,targetelectrodes,]), lwd=3, col=collist[3])     

chanindex <- match(toupper(chanlabels),toupper(chanlocs$Electrode))
chanxy <- chanlocs[chanindex,2:3]
lines(150*chanlocs$OutlineX-100,7.5*chanlocs$OutlineY + 6, lwd=2)
lines(150*chanlocs$NoseX-100,7.5*chanlocs$NoseY + 6, lwd=2)
lines(150*chanlocs$LearX-100,7.5*chanlocs$LearY + 6, lwd=2)
lines(150*chanlocs$RearX-100,7.5*chanlocs$RearY + 6, lwd=2)
points(150*chanlocs$X_position[1:64]-100,7.5*chanlocs$Y_position[1:64] + 6, pch=16,col='lightgrey')
points(150*chanlocs$X_position[chanindex[targetelectrodes]]-100,7.5*chanlocs$Y_position[chanindex[targetelectrodes]] + 6, pch=16,col='black')

allbfs <- ERP_BF[3,]

linestartstop <- times[allbfs>=3 & allbfs<10]
if (length(linestartstop)>1){xpairs <- getstartstop(linestartstop)
for (n in 1:((length(xpairs)/2)-1)){polygon(xpairs[n,c(1,2,2,1)], -c(8.5,8.5,7.5,7.5), col=bfcols[1],border=NA)}}

linestartstop <- times[allbfs>=10 & allbfs<30]
if (length(linestartstop)>1){xpairs <- getstartstop(linestartstop)
for (n in 1:((length(xpairs)/2)-1)){polygon(xpairs[n,c(1,2,2,1)], -c(8.5,8.5,7.5,7.5), col=bfcols[2],border=NA)}}

linestartstop <- times[allbfs>=30]
if (length(linestartstop)>1){xpairs <- getstartstop(linestartstop)
for (n in 1:((length(xpairs)/2)-1)){polygon(xpairs[n,c(1,2,2,1)], -c(8.5,8.5,7.5,7.5), col=bfcols[3],border=NA)}}

legend(700,12,c('Human','Android'),lty=1,lwd=3,col=collist[c(3,2)],cex=1.8,box.lwd=2)
text(-190,11,'(b)',cex=3)

legend(-200,-6,c('BF>3','BF>10','BF>30'),lwd=5,col=bfcols, box.lwd=2, cex=1.5)


plotlims <- c(-200,1000,0,1) 
ticklocsx <- seq(-200,1000,200)  
ticklocsy <- seq(0,1,0.25)    
ticklabelsx <- ticklocsx      
ticklabelsy <- ticklocsy*100   

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)

mtext(text = ticklabelsx, side = 1, at=ticklocsx,line=0.5,cex=1.5)  
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1,cex=1.5) 
title(xlab="Time (ms)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.8)  #}    
title(ylab="Classifier accuracy (%)", col.lab=rgb(0,0,0), line=2.2, cex.lab=1.8)
text(-190,0.95,'(c)',cex=3)

lines(c(-200, 1000),c(0.5, 0.5), col='black', lty=2)
lines(c(0,0),c(0,1), col='black')

polygon(c(-200:1000,1000:-200), c(mlimits[3,],mlimits[4,1201:1]), col=addalpha(collist[2],0.3),border=NA)


lines(-200:1000,meanMVPA[2,], col=collist[2], lwd=3, cex=0.5)     

allbfs <- mBF[2,]

linestartstop <- times[allbfs>=3 & allbfs<10]
if (length(linestartstop)>1){xpairs <- getstartstop(linestartstop)
for (n in 1:((length(xpairs)/2)-1)){polygon(xpairs[n,c(1,2,2,1)], c(0.24,0.24,0.26,0.26), col=bfcols[1],border=NA)}}

linestartstop <- times[allbfs>=10 & allbfs<30]
if (length(linestartstop)>1){xpairs <- getstartstop(linestartstop)
for (n in 1:((length(xpairs)/2)-1)){polygon(xpairs[n,c(1,2,2,1)], c(0.24,0.24,0.26,0.26), col=bfcols[2],border=NA)}}

linestartstop <- times[allbfs>=30]
if (length(linestartstop)>1){xpairs <- getstartstop(linestartstop)
for (n in 1:((length(xpairs)/2)-1)){polygon(xpairs[n,c(1,2,2,1)], c(0.24,0.24,0.26,0.26), col=bfcols[3],border=NA)}}

legend(-200,0.25,c('BF>3','BF>10','BF>30'),lwd=5,col=bfcols, box.lwd=2, cex=1.5)

plotlims <- c(-200,1000,0,1) 
ticklocsx <- seq(-200,1000,200)  
ticklocsy <- seq(0,1,0.25)    
ticklabelsx <- ticklocsx      
ticklabelsy <- ticklocsy*100   

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)

mtext(text = ticklabelsx, side = 1, at=ticklocsx,line=0.5,cex=1.5)  
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1,cex=1.5) 
title(xlab="Time (ms)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.8)  #}    
title(ylab="Classifier accuracy (%)", col.lab=rgb(0,0,0), line=2.2, cex.lab=1.8)
text(-190,0.95,'(d)',cex=3)

lines(c(-200, 1000),c(0.5, 0.5), col='black', lty=2)
lines(c(0,0),c(0,1), col='black')


polygon(c(-200:1000,1000:-200), c(mlimits[5,],mlimits[6,1201:1]), col=addalpha(collist[3],0.3),border=NA)


lines(-200:1000,meanMVPA[3,], col=collist[3], lwd=3, cex=0.5)    


allbfs <- mBF[3,]

linestartstop <- times[allbfs>=3 & allbfs<10]
if (length(linestartstop)>1){xpairs <- getstartstop(linestartstop)
for (n in 1:((length(xpairs)/2)-1)){polygon(xpairs[n,c(1,2,2,1)], c(0.24,0.24,0.26,0.26), col=bfcols[1],border=NA)}}

linestartstop <- times[allbfs>=10 & allbfs<30]
if (length(linestartstop)>1){xpairs <- getstartstop(linestartstop)
for (n in 1:((length(xpairs)/2)-1)){polygon(xpairs[n,c(1,2,2,1)], c(0.24,0.24,0.26,0.26), col=bfcols[2],border=NA)}}

linestartstop <- times[allbfs>=30]
if (length(linestartstop)>1){xpairs <- getstartstop(linestartstop)
for (n in 1:((length(xpairs)/2)-1)){polygon(xpairs[n,c(1,2,2,1)], c(0.24,0.24,0.26,0.26), col=bfcols[3],border=NA)}}

legend(-200,0.25,c('BF>3','BF>10','BF>30'),lwd=5,col=bfcols, box.lwd=2, cex=1.5)


dev.off()



}

conddprimes <- colMeans(allRobotdprime)
condRTs <- 10^(colMeans(meanRobotRTs)/20)

```

```{r exp1questionnaires, include=FALSE, results='hide'}

qlist <- c('Fake-Natural','Unconscious-Conscious','Apathetic-Responsive','Dislike-Like','Unfriendly-Friendly','Stagnant-Lively','Unintelligent-Intelligent','Irresponsible-Responsible','Anxious-Relaxed','Surprised-Quiescent')

robotQdata <- read.csv('local/robotquestionnairelong.csv')

filelist <- unique(robotQdata$File)
plist <- unique(robotQdata$Participant)
measurelist <- unique(robotQdata$Measure)

sortedQdata <- array(0,dim=c(length(plist),length(filelist),length(measurelist)))
for (file in 1:length(filelist)){
  conddata <- subset(robotQdata,File==filelist[file],)
  for (measure in 1:length(measurelist)){
    measuredata <- subset(conddata,Measure==measurelist[measure])
    for (p in 1:length(plist)){
      pdata <- subset(measuredata,Participant==plist[p])
      
      sortedQdata[p,file,measure] <- pdata$Response
    }
  }
}

conditionQdata <- array(0,dim=c(29,3,10))
conditionQdata[,1,] <- apply(sortedQdata[,1:8,],c(1,3),mean)
conditionQdata[,2,] <- apply(sortedQdata[,9:16,],c(1,3),mean)
conditionQdata[,3,] <- apply(sortedQdata[,17:24,],c(1,3),mean)

meanQdata <- apply(conditionQdata,c(2,3),mean)


pdf(paste0('Figures/RobotRatings.pdf'), bg="transparent", height = 30, width = 12)

par(mfrow=c(5,2))

plotlims <- c(1,5,0.5,3.5)  
ticklocsy <- c(0.5,1,2,3,3.5)    
ticklocsx <- seq(1,5,1)    # locations of tick marks on y axis
ticklabelsy <- c("","Robot","Android","Human","")       
ticklabelsx <- ticklocsx    # set labels for y ticks

for (cond in 1:10){
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx,line=1,cex=1.5)     
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=3,cex=1.5) 
title(xlab=qlist[cond], col.lab=rgb(0,0,0), line=2.4, cex.lab=2)

text(1.15,3.3,paste0('(',letters[cond],')'),cex=3)

a <- density(conditionQdata[,1,cond],cut=6)
a$y <- 0.35*a$y/max(a$y)
polygon(a$x,1.1+a$y,border=NA,col=addalpha(collist[1],0.5))

a <- density(conditionQdata[,2,cond])
a$y <- 0.35*a$y/max(a$y)
polygon(a$x,2.1+a$y,border=NA,col=addalpha(collist[2],0.5))

a <- density(conditionQdata[,3,cond])
a$y <- 0.35*a$y/max(a$y)
polygon(a$x,3.1+a$y,border=NA,col=addalpha(collist[3],0.5))

xvals <- seq(-0.1,0.1,length=nrow(conditionQdata))
points(conditionQdata[,1,cond],1+xvals-0.2,pch=16,col=collist[1])
points(conditionQdata[,2,cond],2+xvals-0.2,pch=15,col=collist[2])
points(conditionQdata[,3,cond],3+xvals-0.2,pch=18,col=collist[3])

for (cond2 in 1:3){
  bs <- NULL
  for (n in 1:nbootstraps){bs[n] <- mean(sample(conditionQdata[,cond2,cond],replace=TRUE))}
  ci <- quantile(bs,c(0.025,0.975))
  arrows(mean(conditionQdata[,cond2,cond]),cond2,ci[1],cond2,angle=90,length=0.1,lwd=3)
  arrows(mean(conditionQdata[,cond2,cond]),cond2,ci[2],cond2,angle=90,length=0.1,lwd=3)
}

points(mean(conditionQdata[,1,cond]),1,pch=21,cex=2,lwd=2,bg=collist[1])
points(mean(conditionQdata[,2,cond]),2,pch=22,cex=2,lwd=2,bg=collist[2])
points(mean(conditionQdata[,3,cond]),3,pch=23,cex=2,lwd=2,bg=collist[3])

}

dev.off()


```

We first explored the behavioural results for identification of human versus non-human stimuli. We calculated d-prime scores to compare sensitivity across conditions. Sensitivity was highest for identifying robots ($d' =$ `r round(conddprimes[1],digits=2)`), but still well above chance for both the human ($d' =$ `r round(conddprimes[3],digits=2)`) and android ($d' =$ `r round(conddprimes[2],digits=2)`) conditions. The Bayes factor score for a one-way ANOVA comparing these three conditions indicated very substantial evidence ($log_{10}BF_{10} =$ `r round(log10(bfdprime),digits=2)`) for a difference between conditions, as illustrated in Figure \ref{fig:RobotsData}a. Pairwise Bayesian t-tests between conditions indicate very convincing differences in sensitivity between robots and androids ($log_{10}BF_{10} =$ `r round(log10(bfcontrasts[1]),digits=2)`) and robots and humans ($log_{10}BF_{10} =$ `r round(log10(bfcontrasts[2]),digits=2)`). The difference between androids and humans ($log_{10}BF_{10} =$ `r round(log10(bfcontrasts[3]),digits=2)`) was also very substantial. The higher d' values for robots (Figure \ref{fig:RobotsData}a) could indicate that these stimuli are more visually salient.

Reaction times also differed between conditions, though the effects were rather smaller. Reactions were fastest for identifying robots (RT = `r round(condRTs[1],digits=0)`ms), compared with humans (RT = `r round(condRTs[3],digits=0)`ms) and androids (RT = `r round(condRTs[2],digits=0)`ms). The Bayes factor score for a one-way ANOVA comparing these three conditions indicated strong evidence ($log_{10}BF_{10} =$ `r round(log10(bfRT),digits=2)`) for a difference between conditions, as illustrated in Figure \ref{fig:RobotsData}b. Pairwise Bayesian t-tests between conditions indicate very convincing differences in sensitivity between robots and androids ($log_{10}BF_{10} =$ `r round(log10(bfcontrastsRT[1]),digits=2)`) and robots and humans ($log_{10}BF_{10} =$ `r round(log10(bfcontrastsRT[2]),digits=2)`), whereas the reaction time was equivalent between androids and humans ($log_{10}BF_{10} =$ `r round(log10(bfcontrastsRT[3]),digits=2)`).

```{r RobotsData, fig.cap="Summary of response data and grand mean ERP for Experiment 1. Panel (a) shows d-prime scores for identifying images of human (blue diamonds), android (green squares) and robot (red circles) faces. Small points show individual participants, and the larger symbols with error bars indicate the group mean and bootstrapped 95\\% confidence intervals. Panel (b) plots reaction times in the same format (note the logarithmic x-axis). Panel (c) shows the grand mean ERP across all participants and conditions, pooled across electrodes P6, P8, PO6 and PO8 (see inset). The P100 is a positive evoked potential occuring around 100ms after onset of a visual stimulus, associated with the initial (low level) visual response; the N170 is a negative potential at 170ms that is often associated with faces; the P200 is a further positive potential linked to attention and stimulus discrimination. The shaded region around the curve illustrates the 95\\% confidence interval, and the grey rectangle at the foot indicates the stimulus duration.", fig.align="center", echo=FALSE}

knitr::include_graphics('Figures/RobotsData.pdf')

```

EEG activity showed a clear visually evoked potential over posterior electrode sites (see Figure \ref{fig:RobotsData}c), with typical components found in response to visual stimuli pooled across all conditions (the P100, N170 and P200 are indicated in the figure). Pairwise comparisons of conditions are shown in Figure \ref{fig:RobotsMVPA}a,b. In general there is a tendency for the ERP response to human faces to diverge slightly from the other two conditions [@Geiger2021], however the evidence for this divergence was not compelling. Bayes factors exceeded 3 for only a small number of time points around 300-400ms in the comparison between human and robot images (see yellow bars at y = -8 in Figure \ref{fig:RobotsMVPA}a), but these differences were small considering the variance in the data.

```{r RobotsMVPA, fig.cap="Univariate and multivariate comparisons across image type. Panel (a) shows the ERPs comparing human (blue) and robot (red) face images, and panel (b) compares human (blue) and android (green) faces. Panels (c) and (d) show multivariate pattern classification accuracy for the same comparisons. Points at y = -8 and y = 25 indicate Bayes factor scores for comparisons between ERPs (a,b) and comparing classification accuracy to chance (50\\% correct; c,d).", fig.align="center", echo=FALSE}

knitr::include_graphics('Figures/RobotsMVPA.pdf')

```

We also conducted multivariate pattern analysis independently at each time-point for the same two comparisons. The evoked responses for human and robot images caused sufficiently distinct patterns of voltages across the scalp that the pattern classifier could distinguish between them from around 100 ms following stimulus onset, with accuracy up to `r round(100*max(meanMVPA[2,]),digits=0)`\% correct (see Figure \ref{fig:RobotsMVPA}c). Bayes factors exceeded 30 for much of the time window between 100 and 800 ms, indicating that the decoding was meaningfully above chance performance (50\% correct). It was also possible to classify between human and android images (see Figure \ref{fig:RobotsMVPA}d), however performance was much poorer, with a maximum of `r round(100*max(meanMVPA[3,]),digits=0)`\% correct. Classification accuracy had an initial peak around 100ms that provided compelling evidence for above chance classification (BF>30), and a later region of above-chance classification between 500 and 700ms. The early time window likely reflects rapid processing of low-level visual features, such as edges or color contrasts, consistent with P100 and N170 components, whereas the later time window may involve higher-level cognitive processes, such as evaluating emotional content or judging authenticity. In the Discussion we speculate that these two time periods might correspond to distinct types of signal associated with the uncanny valley. More generally, the high classification accuracy for human vs. robot stimuli may be attributed to the salient mechanical elements of robots, whereas the lower accuracy for humanoids reflects their ambiguous human-like appearance, leading to confusion.

Finally, we analysed the rating data from a set of 10 questionnaire items for 8 stimuli from each category. The results are summarised in Figure \@ref(fig:robotratings), and in general show differences between stimulus categories along most dimensions. Of particular note, the U-shaped function predicted by the uncanny valley effect was apparent for ratings along the Dislike-Like (Figure \@ref(fig:robotratings)d), Unfriendly-Friendly (Figure \@ref(fig:robotratings)e), and Anxious-Relaxed (Figure \@ref(fig:robotratings)i) dimensions. These are all dimensions with emotional valence, indicating support for the 'uncanniness' of our android stimuli. However we note that the android and robot categories were typically rated as being more similar to each other than to the real human faces. Following Experiment 1, we sought to generalise our results to a different stimulus set, and next report the results of Experiment 2 which used hyper-realistic silicone masks.

```{r robotratings, fig.cap="Ratings of stimuli using items from the Godspeed questionnaire. Each rating was on a Likert scale from 1-5, and was the average of ratings from 8 stimulus examples. Dots show individual participant scores, with the larger symbols indicating the mean and 95\\% bootstrapped confidence intervals.", fig.align="center", out.width="50%", echo=FALSE}

knitr::include_graphics('Figures/RobotRatings.pdf')

```

## Experiment 2

```{r exp2stats, include=FALSE, results='hide'}

# statistical analysis for experiment 2
processeddir <- 'local/masksmvpa/'
excludelist <- c(3,16,24,26,29)

if (processdata > 1){

  if (!file.exists('local/masksmvpa/351_101.mat')){
  osffiles <- osf_retrieve_file('8wmxv')
  osf_download(osffiles, path='local/',progress=TRUE,conflicts='overwrite')
  unzip('local/masksmvpa.zip',exdir='local/',overwrite=TRUE)
  }
    if (!file.exists('local/responsedata/351trialorderMasks.mat')){
  osffiles <- osf_retrieve_file('fvsq8')
  osf_download(osffiles, path='local/',progress=TRUE,conflicts='overwrite')
  unzip('local/responsedata.zip',exdir='local/',overwrite=TRUE)
    }
  
datafiles <- dir(processeddir,pattern='*decoding.mat',full.names=TRUE)    
allmvpa <- array(0,dim=c(length(datafiles),3,1201))  
for (s in 1:length(datafiles)){
  data <- readMat(datafiles[s])
  allmvpa[s,,] <- data$Value/100
}    
times <- data$Time

datafiles1 <- dir(processeddir,pattern='*_101.mat',full.names=TRUE)    
datafiles2 <- dir(processeddir,pattern='*_102.mat',full.names=TRUE)    
datafiles3 <- dir(processeddir,pattern='*_103.mat',full.names=TRUE)    
allmeans <- array(0,dim=c(length(datafiles1),3,66,1201))
for (s in 1:length(datafiles1)){
  data <- readMat(datafiles1[s])
  allmeans[s,1,,] <- data$F*10^6
  data <- readMat(datafiles2[s])
  allmeans[s,2,,] <- data$F*10^6
  data <- readMat(datafiles3[s])
  allmeans[s,3,,] <- data$F*10^6
}     

allmvpa <- allmvpa[-excludelist,,]
allmeans <- allmeans[-excludelist,,,]

  allMaskRTs <- array(0,dim=c(30,3,444))
  allMaskaccuracy <- array(0,dim=c(30,3,444))
  allMaskdprime <- matrix(0,nrow=30,ncol=3)
  allMasktrialcounts <- matrix(0,nrow=30,ncol=3)

  for (s in 1:30){
    data <- readMat(paste0('local/responsedata/',s+350,'trialorderMasks.mat'))
    
    trialorder <- data$R[7][[1]]
    responses <- data$R[9][[1]]
    RTs <- data$R[10][[1]]
    condlist <- data$R[6][[1]]
    condcounter <- c(0,0,0)
    sortedRT <- matrix(0,nrow=3,ncol=444)
    sortedresp <- matrix(0,nrow=3,ncol=444)
    
    for (block in 1:3){
      for (trial in 1:296){
        cond <- condlist[trialorder[block,trial]]
        condcounter[cond] <- condcounter[cond] + 1
        sortedRT[cond,condcounter[cond]] <- 20*log10(RTs[block,trial] * 1000)
        sortedresp[cond,condcounter[cond]] <- responses[block,trial] - 1
      }
    }
    
      hits <- NULL
  misses <- NULL
  for (cond in 1:3){
 
  if (cond<3){
  hits[cond] <- condcounter[cond]-sum(sortedresp[cond,1:condcounter[cond]])
  misses[cond] <- sum(sortedresp[cond,1:condcounter[cond]])
  }
  if (cond==3){
  hits[cond] <- sum(sortedresp[cond,1:condcounter[cond]])
  misses[cond] <- condcounter[cond]-sum(sortedresp[cond,1:condcounter[cond]])
  }
    
  }
    hitrate <- hits/(hits + misses)
  for (cond in 1:3){
    if (cond<3){falsealarms <- misses[3]/ (misses[3] + hits[3])}
    if (cond==3){falsealarms <- sum(misses[1:2]) / (sum(misses[1:2]) + sum(hits[1:2]))}
  allMaskdprime[s,cond] <- qnorm(hitrate[cond]) - qnorm(falsealarms)
  }
    
    allMaskRTs[s,,] <- sortedRT
    allMaskaccuracy[s,,] <- sortedresp
    allMasktrialcounts[s,] <- condcounter
  }
  
allMaskdprime[which(is.infinite(allMaskdprime))] <- 5

meanMaskRTs <- matrix(0,nrow=30,ncol=3)
for (s in 1:30){
  for (cond in 1:3){
    meanMaskRTs[s,cond] <- mean(allMaskRTs[s,cond,1:allMasktrialcounts[s,cond]])
  }
}

dataforANOVA <- melt(allMaskdprime)
colnames(dataforANOVA) <- c('Participant','Condition','dprime')
dataforANOVA$Participant <- as.factor(dataforANOVA$Participant)
dataforANOVA$Condition <- as.factor(dataforANOVA$Condition)
bfdprime <- extractBF(anovaBF(dprime ~ Condition,dataforANOVA,whichRandom='Participant'))$bf

bfcontrasts <- NULL
for (comp in 1:3){
bfcontrasts[comp] <- extractBF(ttestBF(allMaskdprime[,comparisons[comp,1]],allMaskdprime[,comparisons[comp,2]],paired=TRUE))$bf}

dataforANOVA <- melt(meanMaskRTs)
colnames(dataforANOVA) <- c('Participant','Condition','RT')
dataforANOVA$Participant <- as.factor(dataforANOVA$Participant)
dataforANOVA$Condition <- as.factor(dataforANOVA$Condition)
bfRT <- extractBF(anovaBF(RT ~ Condition,dataforANOVA,whichRandom='Participant'))$bf

bfcontrastsRT <- NULL
for (comp in 1:3){
bfcontrastsRT[comp] <- extractBF(ttestBF(meanMaskRTs[,comparisons[comp,1]],meanMaskRTs[,comparisons[comp,2]],paired=TRUE))$bf}



subjmeanERP <- apply(allmeans,c(1,3,4),mean)
meanERP <- apply(allmeans,2:4,mean)
meanMVPA <- apply(allmvpa,2:3,mean)
grandmeanERP <- apply(subjmeanERP[,targetelectrodes,],3,mean)
subjERPs <- apply(subjmeanERP[,targetelectrodes,],c(1,3),mean)
condERPs <- apply(allmeans[,,targetelectrodes,],c(1,2,4),mean)

mlimits <- matrix(0,nrow=6,ncol=1201)
mBF <- matrix(0,nrow=3,ncol=1201)
bspop <- 1:nbootstraps
for (n in 1:1201){

  for (cond in 1:3){
  for (b in 1:nbootstraps){
    bspop[b] <- mean(sample(allmvpa[,cond,n],replace=TRUE))
  }
mlimits[(1:2)+((cond-1)*2),n] <- quantile(bspop,probs=c(0.025,0.975)) 
mBF[cond,n] <- extractBF(ttestBF(allmvpa[,cond,n],mu=0.5))$bf
  }
}

comparisons <- matrix(c(1,2,1,3,2,3),nrow=3,ncol=2,byrow=TRUE)
limits <- matrix(0,nrow=8,ncol=1201)
ERP_BF <- matrix(0,nrow=3,ncol=1201)
bspop <- 1:nbootstraps
for (n in 1:1201){

  for (b in 1:nbootstraps){
    bspop[b] <- mean(sample(subjERPs[,n],replace=TRUE))
  }
  limits[1:2,n] <- quantile(bspop,probs=c(0.025,0.975)) 
  
  for (cond in 1:3){
  for (b in 1:nbootstraps){
    bspop[b] <- mean(sample(condERPs[,cond,n],replace=TRUE))
  }
  limits[(1:2)+(cond*2),n] <- quantile(bspop,probs=c(0.025,0.975)) 
  ERP_BF[cond,n] <- extractBF(ttestBF(condERPs[,comparisons[cond,1],n],condERPs[,comparisons[cond,2],n],paired=TRUE))$bf
  }
}


chlist <- readMat('local/channel.mat')
chanlabels <- unlist(chlist$HeadPoints[[2]])
chanlocs <- read.csv('local/channeldata.csv')


save(file='local/GroupDataMasks.RData',list=c('allmeans','allmvpa','mlimits','subjmeanERP','limits','grandmeanERP','subjERPs','condERPs','meanMVPA','meanERP','mBF','ERP_BF','allMaskdprime','meanMaskRTs','bfdprime','bfRT','bfcontrasts','bfcontrastsRT','chanlocs','chanlabels'))
}

```

```{r exp2fig, include=FALSE, results='hide'}

# create figures for experiment 2

  if (!file.exists('local/GroupDataMasks.RData')){
  osfproject <- osf_retrieve_node('uzbns')
  osffiles <- osf_ls_files(osfproject,n_max=100)
  fid <- which(osffiles$name=='GroupDataMasks.RData')
  osf_download(osffiles[fid,], path='local/',progress=TRUE)}

load('local/GroupDataMasks.RData')

if (processdata > 0){

pdf(paste0('Figures/MasksData.pdf'), bg="transparent", height = 12, width = 12)

par(mfrow=c(2,2))

  plotlims <- c(0,5,0.5,3.5)  
  ticklocsy <- c(0.5,1,2,3,3.5)    
  ticklocsx <- 0:5    # locations of tick marks on y axis
  ticklabelsy <- c("","Halloween","Silicone","Human","")       
  ticklabelsx <- ticklocsx    # set labels for y ticks
  
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
  axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
  axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
  mtext(text = ticklabelsx, side = 1, at=ticklocsx,line=0.5,cex=1.5)     
  mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=3,cex=1.5) 
  title(xlab="d prime", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.8)

  text(0.15,3.3,'(a)',cex=3)
  
  a <- density(allMaskdprime[,1],cut=6)
  a$y <- 0.35*a$y/max(a$y)
  polygon(a$x,1.1+a$y,border=NA,col=addalpha(collist[1],0.5))

    a <- density(allMaskdprime[,2])
  a$y <- 0.35*a$y/max(a$y)
  polygon(a$x,2.1+a$y,border=NA,col=addalpha(collist[2],0.5))

    a <- density(allMaskdprime[,3])
  a$y <- 0.35*a$y/max(a$y)
  polygon(a$x,3.1+a$y,border=NA,col=addalpha(collist[3],0.5))

  xvals <- seq(-0.1,0.1,length=nrow(allMaskdprime))
  points(allMaskdprime[,1],1+xvals-0.2,pch=16,col=collist[1])
  points(allMaskdprime[,2],2+xvals-0.2,pch=15,col=collist[2])
  points(allMaskdprime[,3],3+xvals-0.2,pch=18,col=collist[3])

  for (cond in 1:3){
  bs <- NULL
  for (n in 1:nbootstraps){bs[n] <- mean(sample(allMaskdprime[,cond],replace=TRUE))}
  ci <- quantile(bs,c(0.025,0.975))
  arrows(mean(allMaskdprime[,cond]),cond,ci[1],cond,angle=90,length=0.1,lwd=3)
  arrows(mean(allMaskdprime[,cond]),cond,ci[2],cond,angle=90,length=0.1,lwd=3)
  }

  points(mean(allMaskdprime[,1]),1,pch=21,cex=2,lwd=2,bg=collist[1])
  points(mean(allMaskdprime[,2]),2,pch=22,cex=2,lwd=2,bg=collist[2])
  points(mean(allMaskdprime[,3]),3,pch=23,cex=2,lwd=2,bg=collist[3])


  
  plotlims <- c(49,61,0.5,3.5)  
  ticklocsy <- c(0.5,1,2,3,3.5)    
  ticklocsx <- seq(49,61,3)
  ticklabelsy <- c("","Halloween","Silicone","Human","")       
  ticklabelsx <- c('','400','','800','')    # set labels for y ticks
  
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
  axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
  axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
  mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.5, cex=1.5)     
  mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=3,cex=1.5) 
  title(xlab="Reaction time (ms)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.8)

    text(20*log10(300),3.3,'(b)',cex=3)

  a <- density(meanMaskRTs[,1],cut=6)
  a$y <- 0.35*a$y/max(a$y)
  polygon(a$x,1.1+a$y,border=NA,col=addalpha(collist[1],0.5))

    a <- density(meanMaskRTs[,2])
  a$y <- 0.35*a$y/max(a$y)
  polygon(a$x,2.1+a$y,border=NA,col=addalpha(collist[2],0.5))

    a <- density(meanMaskRTs[,3])
  a$y <- 0.35*a$y/max(a$y)
  polygon(a$x,3.1+a$y,border=NA,col=addalpha(collist[3],0.5))

  xvals <- seq(-0.1,0.1,length=nrow(meanMaskRTs))
  points(meanMaskRTs[,1],1+xvals-0.2,pch=16,col=collist[1])
  points(meanMaskRTs[,2],2+xvals-0.2,pch=15,col=collist[2])
  points(meanMaskRTs[,3],3+xvals-0.2,pch=18,col=collist[3])

  for (cond in 1:3){
  bs <- NULL
  for (n in 1:nbootstraps){bs[n] <- mean(sample(meanMaskRTs[,cond],replace=TRUE))}
  ci <- quantile(bs,c(0.025,0.975))
  arrows(mean(meanMaskRTs[,cond]),cond,ci[1],cond,angle=90,length=0.1,lwd=3)
  arrows(mean(meanMaskRTs[,cond]),cond,ci[2],cond,angle=90,length=0.1,lwd=3)
  }
  points(mean(meanMaskRTs[,1]),1,pch=21,cex=2,lwd=2,bg=collist[1])
  points(mean(meanMaskRTs[,2]),2,pch=22,cex=2,lwd=2,bg=collist[2])
  points(mean(meanMaskRTs[,3]),3,pch=23,cex=2,lwd=2,bg=collist[3])


par(mfrow=c(2,1),mfg=c(2,1))

plotlims <- c(-200,1000,-12,12)  
ticklocsx <- seq(-200,1000,200)    # locations of tick marks on x axis
ticklocsy <- seq(-12,12,4)    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.5, cex=1.5)    
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1, cex=1.5)  
title(xlab="Time (ms)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.8)   
title(ylab="Amplitude (µV)", col.lab=rgb(0,0,0), line=2.2, cex.lab=1.8)

  text(-200,10,'(c)',cex=3)

lines(c(-200,1000),c(0,0),lty=1)
lines(c(0,0),c(-20,20),lty=1)
polygon(c(0,250,250,0),c(-13,-13,-11,-11),col=rgb(0,0,0,0.3),border=NA)

polygon(c(-200:1000,1000:-200), c(limits[1,],limits[2,1201:1]), col=rgb(0,0,0,0.1),border=NA)

lines(-200:1000, grandmeanERP, lwd=3)     

  text(105,10,'P100',cex=2)
  text(155,-4,'N170',cex=2)
  text(250,4.5,'P200',cex=2)

  
chanindex <- match(toupper(chanlabels),toupper(chanlocs$Electrode))
chanxy <- chanlocs[chanindex,2:3]
lines(150*chanlocs$OutlineX-100,7.5*chanlocs$OutlineY + 6, lwd=2)
lines(150*chanlocs$NoseX-100,7.5*chanlocs$NoseY + 6, lwd=2)
lines(150*chanlocs$LearX-100,7.5*chanlocs$LearY + 6, lwd=2)
lines(150*chanlocs$RearX-100,7.5*chanlocs$RearY + 6, lwd=2)
points(150*chanlocs$X_position[1:64]-100,7.5*chanlocs$Y_position[1:64] + 6, pch=16,col='lightgrey')
points(150*chanlocs$X_position[chanindex[targetelectrodes]]-100,7.5*chanlocs$Y_position[chanindex[targetelectrodes]] + 6, pch=16,col='black')


dev.off()






pdf(paste0('Figures/MasksMVPA.pdf'), bg="transparent", height = 12, width = 24)

par(mfrow=c(2,2))

times <- -199:1200

plotlims <- c(-200,1000,-12,12)  
ticklocsx <- seq(-200,1000,200)    # locations of tick marks on x axis
ticklocsy <- seq(-12,12,4)    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)    
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.5, cex=1.5)    
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1, cex=1.5)  
title(xlab="Time (ms)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.8)   
title(ylab="Amplitude (µV)", col.lab=rgb(0,0,0), line=2.2, cex.lab=1.8)

lines(c(-200,1000),c(0,0),lty=1)
lines(c(0,0),c(-20,20),lty=1)
polygon(c(0,250,250,0),c(-13,-13,-11,-11),col=rgb(0,0,0,0.3),border=NA)

polygon(c(-200:1000,1000:-200), c(limits[3,],limits[4,1201:1]), col=addalpha(collist[1],0.3),border=NA)
polygon(c(-200:1000,1000:-200), c(limits[7,],limits[8,1201:1]), col=addalpha(collist[3],0.3),border=NA)

lines(-200:1000, colMeans(meanERP[1,targetelectrodes,]), lwd=3, col=collist[1])     
lines(-200:1000, colMeans(meanERP[3,targetelectrodes,]), lwd=3, col=collist[3])     

chanindex <- match(toupper(chanlabels),toupper(chanlocs$Electrode))
chanxy <- chanlocs[chanindex,2:3]
lines(150*chanlocs$OutlineX-100,7.5*chanlocs$OutlineY + 6, lwd=2)
lines(150*chanlocs$NoseX-100,7.5*chanlocs$NoseY + 6, lwd=2)
lines(150*chanlocs$LearX-100,7.5*chanlocs$LearY + 6, lwd=2)
lines(150*chanlocs$RearX-100,7.5*chanlocs$RearY + 6, lwd=2)
points(150*chanlocs$X_position[1:64]-100,7.5*chanlocs$Y_position[1:64] + 6, pch=16,col='lightgrey')
points(150*chanlocs$X_position[chanindex[targetelectrodes]]-100,7.5*chanlocs$Y_position[chanindex[targetelectrodes]] + 6, pch=16,col='black')


allbfs <- ERP_BF[2,]

linestartstop <- times[allbfs>=3 & allbfs<10]
if (length(linestartstop)>1){xpairs <- getstartstop(linestartstop)
for (n in 1:((length(xpairs)/2)-1)){polygon(xpairs[n,c(1,2,2,1)], -c(8.5,8.5,7.5,7.5), col=bfcols[1],border=NA)}}

linestartstop <- times[allbfs>=10 & allbfs<30]
if (length(linestartstop)>1){xpairs <- getstartstop(linestartstop)
for (n in 1:((length(xpairs)/2)-1)){polygon(xpairs[n,c(1,2,2,1)], -c(8.5,8.5,7.5,7.5), col=bfcols[2],border=NA)}}

linestartstop <- times[allbfs>=30]
if (length(linestartstop)>1){xpairs <- getstartstop(linestartstop)
for (n in 1:((length(xpairs)/2)-1)){polygon(xpairs[n,c(1,2,2,1)], -c(8.5,8.5,7.5,7.5), col=bfcols[3],border=NA)}}


legend(700,12,c('Human','Halloween'),lty=1,lwd=3,col=collist[c(3,1)],cex=1.8,box.lwd=2)
text(-190,11,'(a)',cex=3)

legend(-200,-6,c('BF>3','BF>10','BF>30'),lwd=5,col=bfcols, box.lwd=2, cex=1.5)


plotlims <- c(-200,1000,-12,12)  
ticklocsx <- seq(-200,1000,200)    # locations of tick marks on x axis
ticklocsy <- seq(-12,12,4)    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.5, cex=1.5)    
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1, cex=1.5)  
title(xlab="Time (ms)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.8)   
title(ylab="Amplitude (µV)", col.lab=rgb(0,0,0), line=2.2, cex.lab=1.8)

lines(c(-200,1000),c(0,0),lty=1)
lines(c(0,0),c(-20,20),lty=1)
polygon(c(0,250,250,0),c(-13,-13,-11,-11),col=rgb(0,0,0,0.3),border=NA)

polygon(c(-200:1000,1000:-200), c(limits[5,],limits[6,1201:1]), col=addalpha(collist[2],0.3),border=NA)
polygon(c(-200:1000,1000:-200), c(limits[7,],limits[8,1201:1]), col=addalpha(collist[3],0.3),border=NA)

lines(-200:1000, colMeans(meanERP[2,targetelectrodes,]), lwd=3, col=collist[2])     
lines(-200:1000, colMeans(meanERP[3,targetelectrodes,]), lwd=3, col=collist[3])     

chanindex <- match(toupper(chanlabels),toupper(chanlocs$Electrode))
chanxy <- chanlocs[chanindex,2:3]
lines(150*chanlocs$OutlineX-100,7.5*chanlocs$OutlineY + 6, lwd=2)
lines(150*chanlocs$NoseX-100,7.5*chanlocs$NoseY + 6, lwd=2)
lines(150*chanlocs$LearX-100,7.5*chanlocs$LearY + 6, lwd=2)
lines(150*chanlocs$RearX-100,7.5*chanlocs$RearY + 6, lwd=2)
points(150*chanlocs$X_position[1:64]-100,7.5*chanlocs$Y_position[1:64] + 6, pch=16,col='lightgrey')
points(150*chanlocs$X_position[chanindex[targetelectrodes]]-100,7.5*chanlocs$Y_position[chanindex[targetelectrodes]] + 6, pch=16,col='black')


allbfs <- ERP_BF[3,]

linestartstop <- times[allbfs>=3 & allbfs<10]
if (length(linestartstop)>1){xpairs <- getstartstop(linestartstop)
for (n in 1:((length(xpairs)/2)-1)){polygon(xpairs[n,c(1,2,2,1)], -c(8.5,8.5,7.5,7.5), col=bfcols[1],border=NA)}}

linestartstop <- times[allbfs>=10 & allbfs<30]
if (length(linestartstop)>1){xpairs <- getstartstop(linestartstop)
for (n in 1:((length(xpairs)/2)-1)){polygon(xpairs[n,c(1,2,2,1)], -c(8.5,8.5,7.5,7.5), col=bfcols[2],border=NA)}}

linestartstop <- times[allbfs>=30]
if (length(linestartstop)>1){xpairs <- getstartstop(linestartstop)
for (n in 1:((length(xpairs)/2)-1)){polygon(xpairs[n,c(1,2,2,1)], -c(8.5,8.5,7.5,7.5), col=bfcols[3],border=NA)}}


legend(700,12,c('Human','Silicone'),lty=1,lwd=3,col=collist[c(3,2)],cex=1.8,box.lwd=2)
text(-190,11,'(b)',cex=3)

legend(-200,-6,c('BF>3','BF>10','BF>30'),lwd=5,col=bfcols, box.lwd=2, cex=1.5)

plotlims <- c(-200,1000,0,1) 
ticklocsx <- seq(-200,1000,200)  
ticklocsy <- seq(0,1,0.25)    
ticklabelsx <- ticklocsx      
ticklabelsy <- ticklocsy*100   

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)

mtext(text = ticklabelsx, side = 1, at=ticklocsx,line=0.5,cex=1.5)  
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1,cex=1.5) 
title(xlab="Time (ms)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.8)  #}    
title(ylab="Classifier accuracy (%)", col.lab=rgb(0,0,0), line=2.2, cex.lab=1.8)
text(-190,0.95,'(c)',cex=3)

lines(c(-200, 1000),c(0.5, 0.5), col='black', lty=2)
lines(c(0,0),c(0,1), col='black')

polygon(c(-200:1000,1000:-200), c(mlimits[3,],mlimits[4,1201:1]), col=addalpha(collist[2],0.3),border=NA)


lines(-200:1000,meanMVPA[2,], col=collist[2], lwd=3, cex=0.5)     

allbfs <- mBF[2,]

linestartstop <- times[allbfs>=3 & allbfs<10]
if (length(linestartstop)>1){xpairs <- getstartstop(linestartstop)
for (n in 1:((length(xpairs)/2)-1)){polygon(xpairs[n,c(1,2,2,1)], c(0.24,0.24,0.26,0.26), col=bfcols[1],border=NA)}}

linestartstop <- times[allbfs>=10 & allbfs<30]
if (length(linestartstop)>1){xpairs <- getstartstop(linestartstop)
for (n in 1:((length(xpairs)/2)-1)){polygon(xpairs[n,c(1,2,2,1)], c(0.24,0.24,0.26,0.26), col=bfcols[2],border=NA)}}

linestartstop <- times[allbfs>=30]
if (length(linestartstop)>1){xpairs <- getstartstop(linestartstop)
for (n in 1:((length(xpairs)/2)-1)){polygon(xpairs[n,c(1,2,2,1)], c(0.24,0.24,0.26,0.26), col=bfcols[3],border=NA)}}

legend(-200,0.25,c('BF>3','BF>10','BF>30'),lwd=5,col=bfcols, box.lwd=2, cex=1.5)

plotlims <- c(-200,1000,0,1) 
ticklocsx <- seq(-200,1000,200)  
ticklocsy <- seq(0,1,0.25)    
ticklabelsx <- ticklocsx      
ticklabelsy <- ticklocsy*100   

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)

mtext(text = ticklabelsx, side = 1, at=ticklocsx,line=0.5,cex=1.5)  
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1,cex=1.5) 
title(xlab="Time (ms)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.8)  #}    
title(ylab="Classifier accuracy (%)", col.lab=rgb(0,0,0), line=2.2, cex.lab=1.8)
text(-190,0.95,'(d)',cex=3)

lines(c(-200, 1000),c(0.5, 0.5), col='black', lty=2)
lines(c(0,0),c(0,1), col='black')


polygon(c(-200:1000,1000:-200), c(mlimits[5,],mlimits[6,1201:1]), col=addalpha(collist[3],0.3),border=NA)


lines(-200:1000,meanMVPA[3,], col=collist[3], lwd=3, cex=0.5)    


allbfs <- mBF[3,]

linestartstop <- times[allbfs>=3 & allbfs<10]
if (length(linestartstop)>1){xpairs <- getstartstop(linestartstop)
for (n in 1:((length(xpairs)/2)-1)){polygon(xpairs[n,c(1,2,2,1)], c(0.24,0.24,0.26,0.26), col=bfcols[1],border=NA)}}

linestartstop <- times[allbfs>=10 & allbfs<30]
if (length(linestartstop)>1){xpairs <- getstartstop(linestartstop)
for (n in 1:((length(xpairs)/2)-1)){polygon(xpairs[n,c(1,2,2,1)], c(0.24,0.24,0.26,0.26), col=bfcols[2],border=NA)}}

linestartstop <- times[allbfs>=30]
if (length(linestartstop)>1){xpairs <- getstartstop(linestartstop)
for (n in 1:((length(xpairs)/2)-1)){polygon(xpairs[n,c(1,2,2,1)], c(0.24,0.24,0.26,0.26), col=bfcols[3],border=NA)}}

legend(-200,0.25,c('BF>3','BF>10','BF>30'),lwd=5,col=bfcols, box.lwd=2, cex=1.5)

dev.off()



}

conddprimes <- colMeans(allMaskdprime)
condRTs <- 10^(colMeans(meanMaskRTs)/20)

```

```{r exp2questionnaires, include=FALSE, results='hide'}

maskQdata <- read.csv('local/maskquestionnairelong.csv')
comparisons <- matrix(c(1,2,1,3,2,3),nrow=3,ncol=2,byrow=TRUE)

hits <- matrix(0,nrow=20,ncol=3)
misses <- matrix(0,nrow=20,ncol=3)

accdata <- subset(maskQdata,maskQdata$Measure=='Acc')
for (s in 1:20){
  thissubj <- subset(accdata,accdata$Participant==s)
  condition <- NULL
  for (i in 1:nrow(thissubj)){
    if (grepl('hm',thissubj$File[i])){condition[i] <- 1}
    if (grepl('sm',thissubj$File[i])){condition[i] <- 2}    
    if (grepl('rf',thissubj$File[i])){condition[i] <- 3}
  }
  for (i in 1:nrow(thissubj)){
    hits[s,condition[i]] <- hits[s,condition[i]] + thissubj$Response[i] 
    misses[s,condition[i]] <- misses[s,condition[i]] + (1-thissubj$Response[i])
  }}

hitrate <- hits / (hits + misses)
falsealarms <- 0*hitrate
falsealarms[,1] <- misses[,3] / (misses[,3] + hits[,3])
falsealarms[,2] <- misses[,3] / (misses[,3] + hits[,3])
falsealarms[,3] <- rowMeans(misses[,1:2]) / (rowMeans(misses[,1:2]) + rowMeans(hits[,1:2]))

subjdprime <- qnorm(hitrate) - qnorm(falsealarms)
subjdprime[which(is.infinite(subjdprime))] <- 5
meandprimes <- colMeans(subjdprime)


condlist <- unique(maskQdata$Condition)
plist <- unique(maskQdata$Participant)
measurelist <- unique(maskQdata$Measure)

averageQdata <- array(0,dim=c(length(plist),length(condlist),length(measurelist)))

for (cond in 1:length(condlist)){
  conddata <- subset(maskQdata,Condition==condlist[cond],)
  for (measure in 1:length(measurelist)){
    measuredata <- subset(conddata,Measure==measurelist[measure])
    for (p in 1:length(plist)){
      pdata <- subset(measuredata,Participant==plist[p])
      
      averageQdata[p,cond,measure] <- mean(pdata$Response)
    }
  }
}
meanQscores <- apply(averageQdata,2:3,mean)

dataforANOVA <- melt(subjdprime)
colnames(dataforANOVA) <- c('Participant','Condition','dprime')
dataforANOVA$Participant <- as.factor(dataforANOVA$Participant)
dataforANOVA$Condition <- as.factor(dataforANOVA$Condition)
bfdprime2 <- extractBF(anovaBF(dprime ~ Condition,dataforANOVA,whichRandom='Participant'))$bf

bfcontrasts2 <- NULL
for (comp in 1:3){
bfcontrasts2[comp] <- extractBF(ttestBF(subjdprime[,comparisons[comp,1]],subjdprime[,comparisons[comp,2]],paired=TRUE))$bf}



dataforANOVA <- melt(averageQdata[,,1])
colnames(dataforANOVA) <- c('Participant','Condition','dprime')
dataforANOVA$Participant <- as.factor(dataforANOVA$Participant)
dataforANOVA$Condition <- as.factor(dataforANOVA$Condition)
bfEmoE <- extractBF(anovaBF(dprime ~ Condition,dataforANOVA,whichRandom='Participant'))$bf

bfcontrastsEmoE <- NULL
for (comp in 1:3){
bfcontrastsEmoE[comp] <- extractBF(ttestBF(averageQdata[,comparisons[comp,1],1],averageQdata[,comparisons[comp,2],1],paired=TRUE))$bf}



dataforANOVA <- melt(averageQdata[,,2])
colnames(dataforANOVA) <- c('Participant','Condition','dprime')
dataforANOVA$Participant <- as.factor(dataforANOVA$Participant)
dataforANOVA$Condition <- as.factor(dataforANOVA$Condition)
bfReal <- extractBF(anovaBF(dprime ~ Condition,dataforANOVA,whichRandom='Participant'))$bf

bfcontrastsReal <- NULL
for (comp in 1:3){
bfcontrastsReal[comp] <- extractBF(ttestBF(averageQdata[,comparisons[comp,1],2],averageQdata[,comparisons[comp,2],2],paired=TRUE))$bf}


dataforANOVA <- melt(averageQdata[,,3])
colnames(dataforANOVA) <- c('Participant','Condition','dprime')
dataforANOVA$Participant <- as.factor(dataforANOVA$Participant)
dataforANOVA$Condition <- as.factor(dataforANOVA$Condition)
bfUncan <- extractBF(anovaBF(dprime ~ Condition,dataforANOVA,whichRandom='Participant'))$bf

bfcontrastsUncan <- NULL
for (comp in 1:3){
bfcontrastsUncan[comp] <- extractBF(ttestBF(averageQdata[,comparisons[comp,1],3],averageQdata[,comparisons[comp,2],3],paired=TRUE))$bf}



if (processdata > 0){

pdf(paste0('Figures/MaskRatings.pdf'), bg="transparent", height = 12, width = 12)

par(mfrow=c(2,2))

plotlims <- c(1,7,0.5,3.5)  
ticklocsy <- c(0.5,1,2,3,3.5)    
ticklocsx <- seq(1,7,1)    # locations of tick marks on y axis
ticklabelsy <- c("","Halloween","Silicone","Human","")       
ticklabelsx <- ticklocsx    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx,line=0.5,cex=1.5)     
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=3,cex=1.5) 
title(xlab="Emotional Expressiveness", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.8)

text(1.15,3.3,'(a)',cex=3)

a <- density(averageQdata[,1,1],cut=6)
a$y <- 0.35*a$y/max(a$y)
polygon(a$x,1.1+a$y,border=NA,col=addalpha(collist[1],0.5))

a <- density(averageQdata[,2,1])
a$y <- 0.35*a$y/max(a$y)
polygon(a$x,2.1+a$y,border=NA,col=addalpha(collist[2],0.5))

a <- density(averageQdata[,3,1])
a$y <- 0.35*a$y/max(a$y)
polygon(a$x,3.1+a$y,border=NA,col=addalpha(collist[3],0.5))

xvals <- seq(-0.1,0.1,length=nrow(averageQdata))
points(averageQdata[,1,1],1+xvals-0.2,pch=16,col=collist[1])
points(averageQdata[,2,1],2+xvals-0.2,pch=15,col=collist[2])
points(averageQdata[,3,1],3+xvals-0.2,pch=18,col=collist[3])

for (cond in 1:3){
  bs <- NULL
  for (n in 1:nbootstraps){bs[n] <- mean(sample(averageQdata[,cond,1],replace=TRUE))}
  ci <- quantile(bs,c(0.025,0.975))
  arrows(mean(averageQdata[,cond,1]),cond,ci[1],cond,angle=90,length=0.1,lwd=3)
  arrows(mean(averageQdata[,cond,1]),cond,ci[2],cond,angle=90,length=0.1,lwd=3)
}

points(mean(averageQdata[,1,1]),1,pch=21,cex=2,lwd=2,bg=collist[1])
points(mean(averageQdata[,2,1]),2,pch=22,cex=2,lwd=2,bg=collist[2])
points(mean(averageQdata[,3,1]),3,pch=23,cex=2,lwd=2,bg=collist[3])



plotlims <- c(1,7,0.5,3.5)  
ticklocsy <- c(0.5,1,2,3,3.5)    
ticklocsx <- seq(1,7,1)    # locations of tick marks on y axis
ticklabelsy <- c("","Halloween","Silicone","Human","")       
ticklabelsx <- ticklocsx    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx,line=0.5,cex=1.5)     
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=3,cex=1.5) 
title(xlab="Realism", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.8)

text(1.15,3.3,'(b)',cex=3)

a <- density(averageQdata[,1,2],cut=6)
a$y <- 0.35*a$y/max(a$y)
polygon(a$x,1.1+a$y,border=NA,col=addalpha(collist[1],0.5))

a <- density(averageQdata[,2,2])
a$y <- 0.35*a$y/max(a$y)
polygon(a$x,2.1+a$y,border=NA,col=addalpha(collist[2],0.5))

a <- density(averageQdata[,3,2])
a$y <- 0.35*a$y/max(a$y)
polygon(a$x,3.1+a$y,border=NA,col=addalpha(collist[3],0.5))

xvals <- seq(-0.1,0.1,length=nrow(averageQdata))
points(averageQdata[,1,2],1+xvals-0.2,pch=16,col=collist[1])
points(averageQdata[,2,2],2+xvals-0.2,pch=15,col=collist[2])
points(averageQdata[,3,2],3+xvals-0.2,pch=18,col=collist[3])

for (cond in 1:3){
  bs <- NULL
  for (n in 1:nbootstraps){bs[n] <- mean(sample(averageQdata[,cond,2],replace=TRUE))}
  ci <- quantile(bs,c(0.025,0.975))
  arrows(mean(averageQdata[,cond,2]),cond,ci[1],cond,angle=90,length=0.1,lwd=3)
  arrows(mean(averageQdata[,cond,2]),cond,ci[2],cond,angle=90,length=0.1,lwd=3)
}

points(mean(averageQdata[,1,2]),1,pch=21,cex=2,lwd=2,bg=collist[1])
points(mean(averageQdata[,2,2]),2,pch=22,cex=2,lwd=2,bg=collist[2])
points(mean(averageQdata[,3,2]),3,pch=23,cex=2,lwd=2,bg=collist[3])



plotlims <- c(1,7,0.5,3.5)  
ticklocsy <- c(0.5,1,2,3,3.5)    
ticklocsx <- seq(1,7,1)    # locations of tick marks on y axis
ticklabelsy <- c("","Halloween","Silicone","Human","")       
ticklabelsx <- ticklocsx    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx,line=0.5,cex=1.5)     
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=3,cex=1.5) 
title(xlab="Uncanniness", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.8)

text(1.15,3.3,'(c)',cex=3)

a <- density(averageQdata[,1,3],cut=6)
a$y <- 0.35*a$y/max(a$y)
polygon(a$x,1.1+a$y,border=NA,col=addalpha(collist[1],0.5))

a <- density(averageQdata[,2,3])
a$y <- 0.35*a$y/max(a$y)
polygon(a$x,2.1+a$y,border=NA,col=addalpha(collist[2],0.5))

a <- density(averageQdata[,3,3])
a$y <- 0.35*a$y/max(a$y)
polygon(a$x,3.1+a$y,border=NA,col=addalpha(collist[3],0.5))

xvals <- seq(-0.1,0.1,length=nrow(averageQdata))
points(averageQdata[,1,3],1+xvals-0.2,pch=16,col=collist[1])
points(averageQdata[,2,3],2+xvals-0.2,pch=15,col=collist[2])
points(averageQdata[,3,3],3+xvals-0.2,pch=18,col=collist[3])

for (cond in 1:3){
  bs <- NULL
  for (n in 1:nbootstraps){bs[n] <- mean(sample(averageQdata[,cond,3],replace=TRUE))}
  ci <- quantile(bs,c(0.025,0.975))
  arrows(mean(averageQdata[,cond,3]),cond,ci[1],cond,angle=90,length=0.1,lwd=3)
  arrows(mean(averageQdata[,cond,3]),cond,ci[2],cond,angle=90,length=0.1,lwd=3)
}

points(mean(averageQdata[,1,3]),1,pch=21,cex=2,lwd=2,bg=collist[1])
points(mean(averageQdata[,2,3]),2,pch=22,cex=2,lwd=2,bg=collist[2])
points(mean(averageQdata[,3,3]),3,pch=23,cex=2,lwd=2,bg=collist[3])



plotlims <- c(0,5,0.5,3.5)  
ticklocsy <- c(0.5,1,2,3,3.5)    
ticklocsx <- seq(0,5,1)    # locations of tick marks on y axis
ticklabelsy <- c("","Halloween","Silicone","Human","")       
ticklabelsx <- ticklocsx    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx,line=0.5,cex=1.5)     
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=3,cex=1.5) 
title(xlab="d prime", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.8)

text(0.15,3.3,'(d)',cex=3)

a <- density(subjdprime[,1],cut=6)
a$y <- 0.35*a$y/max(a$y)
polygon(a$x,1.1+a$y,border=NA,col=addalpha(collist[1],0.5))

a <- density(subjdprime[,2])
a$y <- 0.35*a$y/max(a$y)
polygon(a$x,2.1+a$y,border=NA,col=addalpha(collist[2],0.5))

a <- density(subjdprime[,3])
a$y <- 0.35*a$y/max(a$y)
polygon(a$x,3.1+a$y,border=NA,col=addalpha(collist[3],0.5))

xvals <- seq(-0.1,0.1,length=nrow(subjdprime))
points(subjdprime[,1],1+xvals-0.2,pch=16,col=collist[1])
points(subjdprime[,2],2+xvals-0.2,pch=15,col=collist[2])
points(subjdprime[,3],3+xvals-0.2,pch=18,col=collist[3])

for (cond in 1:3){
  bs <- NULL
  for (n in 1:nbootstraps){bs[n] <- mean(sample(subjdprime[,cond],replace=TRUE))}
  ci <- quantile(bs,c(0.025,0.975))
  arrows(mean(subjdprime[,cond]),cond,ci[1],cond,angle=90,length=0.1,lwd=3)
  arrows(mean(subjdprime[,cond]),cond,ci[2],cond,angle=90,length=0.1,lwd=3)
}

points(mean(subjdprime[,1]),1,pch=21,cex=2,lwd=2,bg=collist[1])
points(mean(subjdprime[,2]),2,pch=22,cex=2,lwd=2,bg=collist[2])
points(mean(subjdprime[,3]),3,pch=23,cex=2,lwd=2,bg=collist[3])

dev.off()

}

```

The results of Experiment 2 were similar to those of Experiment 1, despite using a quite different stimulus set involving images of humans wearing masks, rather than robots. Sensitivity was highest for identifying Halloween masks ($d' =$ `r round(conddprimes[1],digits=2)`), but still well above chance for both the human ($d' =$ `r round(conddprimes[3],digits=2)`) and silicone mask ($d' =$ `r round(conddprimes[2],digits=2)`) conditions. The Bayes factor score for a one-way ANOVA comparing these three conditions indicated very substantial evidence ($log_{10}BF_{10} =$ `r round(log10(bfdprime),digits=2)`) for a difference between conditions, as illustrated in Figure \ref{fig:MasksData}a. Pairwise Bayesian t-tests between conditions indicate very convincing differences in sensitivity between Halloween and silicone masks ($log_{10}BF_{10} =$ `r round(log10(bfcontrasts[1]),digits=2)`) between Halloween masks and humans ($log_{10}BF_{10} =$ `r round(log10(bfcontrasts[2]),digits=2)`), and between silicone masks and humans ($log_{10}BF_{10} =$ `r round(log10(bfcontrasts[3]),digits=2)`). Unlike in Experiment 1, there were no convincing reaction time differences between conditions ($log_{10}BF_{10} =$ `r round(log10(bfRT),digits=2)`), as illustrated in Figure \ref{fig:MasksData}b.

```{r MasksData, fig.cap="Summary of response data and grand mean ERP for Experiment 2. Panel (a) shows d-prime scores for identifying images of human faces (blue diamonds), silicone masks (green squares) and Halloween masks (red circles). Small points show individual participants, and the larger symbols with error bars indicate the group mean and bootstrapped 95\\% confidence intervals. Panel (b) plots reaction times in the same format (note the logarithmic x-axis). Panel (c) shows the grand mean ERP across all participants and conditions, pooled across electrodes P6, P8, PO6 and PO8 (see inset). The shaded region around the curve illustrates the 95\\% confidence interval, and the grey rectangle at the foot indicates the stimulus duration.", fig.align="center", echo=FALSE}

knitr::include_graphics('Figures/MasksData.pdf')

```

The grand average ERP waveform for Experiment 2 (see Figure \ref{fig:MasksData}c) had similar initial components as for Experiment 1. The latter portion of the waveforms differed somewhat, most likely owing to the difference in presentation duration across experiments (250ms versus 500ms). There was a substantial univariate difference in ERP response between human and Halloween mask conditions extending from around 170 to 230ms following stimulus onset (see Figure \ref{fig:MasksMVPA}a), with Bayes factors exceeding 30. Univariate differences between the human and silicone mask conditions were not compelling (see Figure \ref{fig:MasksMVPA}b).

```{r MasksMVPA, fig.cap="Univariate and multivariate comparisons across image type for Experiment 2. Panel (a) shows the ERPs comparing human faces (blue) and Halloween masks (red), and panel (b) compares human faces (blue) and silicone masks (green). Panels (c) and (d) show multivariate pattern classification accuracy for the same comparisons. Points at y = -8 and y = 25 indicate Bayes factor scores for comparisons between ERPs (a,b) and comparing classification accuracy to chance (50\\% correct; c,d).", fig.align="center", echo=FALSE}

knitr::include_graphics('Figures/MasksMVPA.pdf')

```

Multivariate pattern analysis revealed extremely high classification accuracy (up to `r round(100*max(meanMVPA[2,]),digits=0)`\% correct) comparing human faces with Halloween masks. This was convincingly above chance, with a Bayes factor score exceeding 30 from around 100ms following stimulus onset, and extending across the full time window (see Figure \ref{fig:MasksMVPA}c). Classification was also convincingly above chance when comparing human faces with silicone masks (Figure \ref{fig:MasksMVPA}d). This timecourse had an initial peak of high accuracy (up to `r round(100*max(meanMVPA[3,]),digits=0)`\% correct) between 100 and 200ms after stimulus onset, followed by a second peak around 600ms. This replicates the finding from Experiment 1 that uncanny valley responses might involve two distinct components at different moments in time.

We subsequently obtained ratings from an independent sample of 20 participants using the same stimuli as in the EEG experiment. This time, we asked for explicit ratings of emotional expressiveness, realism, and uncanniness, as well as repeating the binary real face vs mask rating. Real faces were rated highest for emotional expressiveness (M=`r round(mean(averageQdata[,3,1]),digits=1)`) and realism (M=`r round(mean(averageQdata[,3,2]),digits=1)`), and lowest for uncanniness (M=`r round(mean(averageQdata[,3,3]),digits=1)`) (Figure \@ref(fig:maskratings)a-c). The realistic silicone masks were rated highest for uncanniness (M=`r round(mean(averageQdata[,2,3]),digits=1)`), however this was not dramatically higher than for the Halloween masks (M=`r round(mean(averageQdata[,1,3]),digits=1)`). Arguably making judgements of uncanniness is less appropriate for masks that are not intended to be realistic, though our data do qualitatively conform to the U-shaped function expected by the uncanny valley hypothesis. The pattern of d-prime scores (Figure \@ref(fig:maskratings)d) was similar to those obtained in the main experiment (Figure \@ref(fig:MasksData)b), with generally higher scores attributable to the unlimited inspection time permitted in this online follow-up experiment

```{r maskratings, fig.cap="Additional ratings of mask images, completed by an independent sample (N=20) with unlimited inspection time. Images were rated on three dimensions using seven-point scales (panels a-c), and also judged as being either a real face or a mask, from which d-prime scores were calculated (panel d).", fig.align="center", out.width="70%", echo=FALSE}

knitr::include_graphics('Figures/MaskRatings.pdf')

```

# Discussion

Across two experiments using diverse stimuli, we identified a potential neurophysiological signature of the 'uncanny valley' effect. EEG responses to androids or silicone masks could be distinguished from responses to human faces at around 100ms after stimulus onset, and also in a later time window around 500-800ms after stimulus onset. There were no clear differences in the unimodal ERP response at posterior electrodes, but performance of a multivariate pattern classifier was above chance in these time windows. This is a different pattern from that observed for more obviously non-human stimuli (robots and Halloween masks), where there were both univariate and multivariate differences, and the multivariate discrimination accuracy was above chance for an extended time window. Perceptual judgements indicated that identification performance for uncanny valley stimuli was relatively poor, indicating confusion with real human images. We also confirmed that android images were perceived more negatively than either human or robot images, and that silicone masks were perceived as more uncanny than human faces. The similarity in results across our two experiments is striking and constitutes an internal conceptual replication of our main findings, suggesting that the neural characteristics of the uncanny valley effect are generalizable across stimulus categories.

The early time window when pattern classification is above chance corresponds approximately to the P100 and N170 components of the ERP. The P100 is typically associated with low-level visual responses, and is affected by contrast and spatial frequency content of an image. The N170 component is most often associated with faces, though is also observed for other image categories, and there is still debate about its precise function [@Thierry2007; @Hong2022]. Similar early components have also been investigated in other ERP studies on the uncanny valley effect [@Schindler2017; @Mustafa2016], and comparing human and robot faces [@Geiger2021]. This time window is unlikely to be modulated substantially by top-down influences, so we attribute the early component to image-based differences between stimulus categories [@Coggan2016]. ERP components in later time windows have also been studied in previous work [@Urgen2018; @Mustafa2017; @Cheetham2015], and may reflect cognitive processing stages, such as determining whether a stimulus conforms to categorical expectations. Differences between stimulus categories at these times are more amenable to top-down influences, and most likely involve higher brain areas outside of occipital cortex. We therefore predict that ERP components at later time points should correspond with perceptual judgements and reports of uncanniness - this is a worthwhile hypothesis for future work to investigate.

Our use of hyper-realistic silicone masks is novel in the context of the study of uncanny valley effects. Previous studies using these masks have demonstrated that they are difficult to distinguish from real faces [@Sanders2017; @Sanders2019], including in applied settings such as simulated passport control [@Robertson2020; @Robertson2024], and show large individual differences [@Sanders2018]. Image analysis indicates that good identification performance for silicone masks is typically based on attention to the region below the eyes [@Sanders2018], however it is plausible that many observers are not explicitly aware of the cues they use to perform this judgement. This might contribute to both the early and late components identified in this study, and presumably also to the subjective sensation of 'uncanniness' that is characteristic of the phenomenon.

Another increasingly common situation that triggers the 'uncanny valley' experience is in the domain of computer-generated images and movies [@Moshel2022; @Gu2023]. Artificial intelligence algorithms are now able to generate images and movies based on text prompts (for example "a picture of a girl flying a kite in a field") that often include human subjects. However, at time of writing, images of humans often contain errors, such as the presence of too many limbs, digits, teeth etc. Synthetic movies often contain continuity errors, and have issues reproducing biological motion. Many of these errors are subtle and take time to spot, but it is also the case that human observers can report that images look 'wrong' without explicitly knowing why. The neural uncanny valley effect that we report here might prove a useful index of these instinctive reactions, and could even potentially be used to improve artificial intelligence algorithms. For example, images could be penalised for producing neural responses that differed from those for natural images.

More generally, the advantage of measuring neural responses to 'uncanny valley' stimuli is that, without requiring conscious awareness or behavioural responses, they can facilitate detection of near-human stimuli. These types of near-human stimuli are becoming increasingly common in impersonation and identity evasion cases [@Sanders2021]. Simultaneously, we observe a growing market for reducing the uncanny valley effect for the benefit of android and robot integration. Exploring the potential of non-invasive brain recordings will benefit various applied fields as a result.

# Conclusions

We have identified neural correlates of the uncanny valley effect that are consistent across two experiments, using androids and hyper-realistic silicone masks. In both cases, perceptual discrimination from real human faces was possible, but more challenging than discriminating from mechanical robots or Halloween masks. Univariate differences in the ERP signal were unconvincing, but a more sensitive multivariate classification analysis identified differences at both early (100-200ms) and later (around 600ms) time points. These findings suggest the importance of both bottom up and top down influences on the subjective experience of the uncanny valley. Future work might extend these findings to more dynamic stimuli, and explore potential applications for improving android and avatar generation.

# References
